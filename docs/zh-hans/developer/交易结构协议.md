#  标准交易结构

因为 CKB 上的合约脚本不存在接口一说，所以这里我们定义了一系列的交易结构代替对接口的定义，所以可以从理解接口的角度来理解下面所列举的交易结构。这些结构要求最终实现链上交易时必须保证以下几点：

- `CellDeps`, `Inputs` 和 `Outpus` 中的 Cell 类型和数量必须正确；
- 在有明确要求的交易中 Cell 的顺序也必须正确；
- `ActionData` 必须在 `transaction.witnesses` 中明确提供；

> 关于各类型 Cell 的具体技术要求，详见 [Cell 结构协议](Cell-结构协议.md) 。

> CKB 官方的 signall 和 multisigh lock script 所需的 CellDeps 不会在下面交易中列出，但是你仍然应该将其添加到交易的 CellDeps 中。

> 所有的交易手续费都是由交易的发起方进行支付。


## 文档术语与约定

> 本文档一切信息需要基于 [RFC-0022 CKB Transaction Structure](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md) 之上进行理解，如果对于 CKB 的交易结构缺乏足够的理解可能会对读懂本文档造成障碍。

| 术语       | 说明                                                                                                     |
|------------|--------------------------------------------------------------------------------------------------------|
| ActionData | 一段 DAS 交易必须携带的数据，详见 [数据存储方案](数据存储方案.md)                                       |
| NormalCell | CKB 中的 Cell 都有 lock, type, outputs_data 三个必要属性，这里指的是 type 与 outputs_data 为空的一类 Cell |
| FeeCell    | 支付交易所需的各种费用的 NormalCell                                                                      |
| ChangeCell | 存放交易找零的 NormalCell                                                                                |
| ScriptCell | 指部署了合约脚本可执行文件的 Cell                                                                        |

| 符号                       | 说明                                                                                                                                                                             |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [XxxYyyCell]               | 代表 XxxYyyCell 为可选                                                                                                                                                           |
| XxxYyyCell (n)             | 代表 XxxYyyCell 是有序的，这是第 n 个 XxxYyyCell                                                                                                                                  |
| XxxYyyCell {n}             | {4} 代表 XxxYyyCell 有且仅有 4 个<br>{3,} 代表 XxxYyyCell 至少要有 3 个<br/>{,2} 代表 XxxYyyCell 最多有 2 个<br/>{1,4} 代表 XxxYyyCell 数量介于 1 ~ 4 之间                       |
| XxxYyyCell [A]             | 代表交易不同部分的多个 XxxYyyCell 需要满足一致的排序<br/>Inputs/Output/CellDeps 中同样带有 `[A]` 标记的 XxxYyyCell 需要满足一致的排序<br>其中的 A 代表 A 类有序规则，也可以是 B、C |
| ConfigCellXXXX.yyyy        | 指代数据需要去某个 ConfigCell 的 witness 中的特定字段获取，详见[ConfigCell](Cell-结构协议.md#ConfigCell)                                                                        |
| block_hash(XxxYyyCell {n}) | XxxYyyCell {n} 和上述的含意一致， block_hash() 的含意表示要取其中 cell 所在的区块 hash                                                                                            |

> 所有的 hash 都是使用的同一种 hash 算法，即 [ckbhash 算法](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md#crypto-primitives)。


## Keeper 相关交易

### 提案类交易

#### 发起提案(Propose)

这笔交易会创建一个 ProposalCell 并验证相关 PreAccountCell 中账户名的唯一性。这个 ProposalCell 的 `witness.slices` 是一个特殊的 `SliceList` 结构，该结构是对链上账户链的多个切片的描述，因此 CellDeps 中的 AccountCell 和 PreAccountCell 必须按照这个 `SliceList` 结构进行排序，简单来说就是 AccountCell 和 PreAccountCell 必须合并在一个数组中按照 account ID 进行字节升序排序。

**action 结构**

```
table ActionData {
  action: "propose",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellProposal
  // 需包含 witnesses 数据中 slices 所列举的所有 AccountCell 和 PreAccountCell
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  ...
Inputs:
  FeeCell
Outputs:
  ProposalCell
  [ChangeCell]
```

#### 扩展提案(ExtendProposal)

这里的含义是基于现有提案创建新提案，而不是将现有提案消费掉，所以现有 ProposalCell 需要放在 CellDeps 字段。这笔交易需要和创建提案交易一样对 AccountCell 和 PreAccountCell 进行排序。

**action 结构**

```
table ActionData {
  action: "extend_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellProposal
  ProposalCell (n)
  // 需包含 witnesses 数据中 slices 所列举的且不存在于 ProposalCell(n) 中的 AccountCell 和 PreAccountCell
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  ……
Inputs:
  FeeCell
Outputs:
  ProposalCell (n + 1)
  [ChangeCell]
```

#### 确认提案(ConfirmProposal)

提案在被确认之前必须等待 n 个区块高度，n 可以从 `ConfigCellProposal.proposal_min_confirm_interval` 获取。

**action 结构**

```
table ActionData {
  action: "confirm_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  account-cell-type
  pre-account-cell-type
  income-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellAccount
  ConfigCellMain
  ConfigCellProfitRate
  ConfigCellPrice
  ConfigCellProposal
  ConfigCellIncome
Inputs:
  ProposalCell
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  AccountCell
  PreAccountCell {1, }
  ……
  FeeCell // 如果总利润不足 IncomeCell 的存储费，那么输入中可以放入普通 CKB cell 取拼凑一个 IncomeCell
Outputs:
  AccountCell {2, }
  IncomeCell {1, }
  ChangeCell // 必须有一个 ChangeCell 把 ProposalCell.capacity 退还给提案发起者
  [ChangeCell] // 其余的找零可以根据情况需要安排
```

##### AccountCell 与 PreAccountCell 排序

和创建提案交易一样这里 Inputs 中的 AccountCell 和 PreAccountCell 必须合并在一个数组中按照 account ID 进行字节排序（也即按照本交易中的 ProposalCell 的 Witness 里存的 account ID 排序），并且 Outputs 中的 AccountCell 也需要按照 account ID 进行字节排序。

##### 利润分配

当提案确认通过新账户就此注册成功，每个 PreAccountCell 中携带的注册费也将变成 DAS 最关键的利润来源。因此这笔交易需要按照以下规则对利润进行分配：

- 提案发起者的利润分成，比例来自 `ConfigCellProfitRate.proposal_create`；
- 提案通过者的利润分成，比例来自 `ConfigCellProfitRate.proposal_confirm`；
- 渠道商的利润分成，比例来自 `ConfigCellProfitRate.channel`；
- 邀请人的利润分成，比例来自 `ConfigCellProfitRate.inviter`；
- DAS 官方的利润分成，比例为**总利润 - 以上各个角色的利润**；

以上利润中，除了提案通过者的利润分成，其他角色的利润分成都需要放在 IncomeCell 中，避免因为利润不足 61 CKB 而无法转出的问题。因为提案通过者是负责构造交易的角色，所以它可以自己在 Inputs 中放入一些 NormalCell 来凑够 61 CKB 。

> ⚠️ 注意提案发起者的利润是记录在 IncomeCell 中的，但是 ProposalCell.capacity 是需要直接退还给提案发起者的，这样设计的目的主要是为了保证提案发起者能够较快拿回自己创建提案的成本从而避免运行 keeper 需要冻结过多的 CKB。

#### 回收提案(RecycleProposal)

当提案中涉及的 PreAccountCell 被其他 keeper 的确认提案交易花费掉之后，自己原先的相关提案就肯定无法通过了。因此提案的发起者可以通过回收无法通过的提案回收 ProposalCell 占用的 CKB。提案在被回收之前必须等待 n 个区块高度，n 可以从 `ConfigCellProposal.proposal_min_recycle_interval` 获取。

**action 结构**

```
table ActionData {
  action: "recycle_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellProposal
  ConfigCellMain
Inputs:
  ProposalCell
  [FeeCell]
Outputs:
  ChangeCell // 必须有一个 ChangeCell 把 ProposalCell.capacity 退还给提案发起者
  [ChangeCell] // 其余的找零可以根据情况需要安排
```

### IncomeCell 相关交易

#### 创建(CreateIncome)

任何人都可以执行这笔交易创建 IncomeCell ，但是这种行为没有经济激励，所以此交易主要是 DAS 官方来根据链上情况动态的创建并保持一定数量的空 IncomeCell 。这些空 IncomeCell 无法用于合并，但是能在通过提案交易中用于接收利润，解决提案交易中的利润不足 IncomeCell 存储费的情况。

**action 结构**

```
table ActionData {
  action: "create_income",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  income-cell-type
  ConfigCellMain
  ConfigCellIncome
Inputs:
  FeeCell
Outputs:
  IncomeCell
  [ChangeCell]
```

#### 合并(ConsolidateIncome)

这笔交易主要的作用是把存放在 IncomeCell 中的利润释放出来转给利润的所有者，其必须遵循以下约束：

- 对于空的 IncomeCell ，**只有一条账目并且是创建者支付的存储费，这种 IncomeCell 不能被合并**；
- 合并的输入必须是 2 个或以上的 IncomeCell；
- 合并的输出的所有 IncomeCell 中，账目记录的总数必须比输入更少；
- 合并的输出的所有 IncomeCell 中，其中同一个 lock script 的账目记录只能有一条；
- 对于**扣除完合并奖励手续费后的金额满足最小转出额的 lock script** （可从 `ConfigCellIncome.min_transfer_capacity` 获取这个最小转出额），应当将它所拥有的金额直接转出到此 lock script，除非转出完成后输出中的 IncomeCell 缺少足够的存储费；
- 转账给 lock script 时，合并交易的发起人可以按照 `ConfigCellProfitRate.income_consolidate` 中配置项拿走部分做为手续费；
- 如果转账的 lock script 是某个 inputs 中 IncomeCell 的创建者或者 DAS 的收款 lock script，那么合并交易的发起人不可以从这笔转账中拿走手续费；
- 因为转出而导致输出中的 IncomeCell 缺少足够存储费的交易，被称为**需要填充的交易**，合约的判断逻辑明细如下；
  - 将所有无法转出的 Records 加总，计算总数量 `n` 和总 capacity `x` ；
  - 如果 `x ÷ n <= basic_capacity_of_income_cell` 那就认为有部分 IncomeCell 缺少足够的存储费，可以进行填充；
- 对于**需要填充的交易**，可以拿应当转出的金额中的一部分进行填充，具体用多少填充取决于合并交易发起者；

> IncomeCell 需要的存储费可以从 `ConfigCellIncome.basic_capacity` 获取。

**Example**

假设现在配置中的存储费是 200 CKB，最小转出额是 100 CKB，现在有两个 IncomeCell ：

```
IncomeCell A:
  creator: lock-a
  lock-a: 200 CKB
  lock-b: 99 CKB
  lock-c: 99 CKB
  lock-d: 5 CKB

IncomeCell B:
  creator: lock-a
  lock-a: 200 CKB
  lock-b: 1 CKB
  lock-c: 1 CKB
  lock-e: 5 CKB
```

那么合并后的结果就可以是 ：

```
IncomeCell C:
  creator: null // 使用 Script::default() 即可
  lock-a: 190 CKB // 实际上 lock-a, lock-b, lock-c 任意一人或多人留下 190 CKB 即可
  lock-d: 5 CKB
  lock-e: 5 CKB

Cell:
	lock-a: 210 CKB
Cell:
	lock-b: 100 CKB
Cell:
	lock-c: 100 CKB
```

这里 a、b 或 c 任一人或多人留下足够维持 IncomeCell 存储费的 CKB 即可，因为 lock-d 和 lock-e 的金额太少无法转出，导致 IncomeCell 无法销毁。具体 IncomeCell 中留多留少合约不做限制，但是能够转出越多，合并交易发起人可以拿到的手续费越多，所以这里合并交易发起人根据自己的能力尽可能多拿即可。

**action 结构**

```
table ActionData {
  action: "consolidate_income",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  income-cell-type
  ConfigCellIncome
  ConfigCellProfitRate
  ConfigCellMain
Inputs:
  IncomeCell {2, }
  [FeeCell]
Outputs:
  IncomeCell {1, }
  NormalCell {1, }
  [ChangeCell]
```

### 运行维护类交易

#### 强制还原账户(ForceRecoverAccountStatus)

当账户处于非普通状态时，即 `witness.status != 0` 时，同时账户又到达了生命周期中的**宽限期**，那么此时 Keeper 可以**强制还原账户的状态**，以便在
账户**完全到期**后进行到期账户拍卖，以及到期拍卖失败时进行账户回收。

> 对于竞拍中的账户，如果已经有人出价了，那么 Keeper 就不能强制还原了。但是 AccountCell 进入**宽限期**后，竞拍者也不能再通过 AccountAuctionCell
> 进行出价，竞拍时间结束后账户就成交给最后的出价者。

**action 结构**

```
table ActionData {
  action: "force_recover_account_status",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  [account-sale-cell-type]
  [account-auction-cell-type]
  balance-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell
  [AccountSaleCell] // 如果账户 status == 1，那么就必须携带对应的 AccountSaleCell
  [AccountAuctionCell] // 如果账户 status == 2，那么就必须携带对应的 AccountAuctionCell
Outputs:
  AccountCell
  ChangeCell // 发生 AccountSaleCell, AccountAuctionCell 被销毁等情况时，必须退还用户其中的 capacity
```

**约定**

- AccountCell 必须是**出售中**或**拍卖中**，即 1 或 2；
- 销毁 AccountSaleCell, AccountAuctionCell 时，这些 Cell 的 capacity 必须以 BalanceCell 的形式退还用户；
- Keeper 可以从退还的金额中拿出 10_000 shannon 作为交易手续费；

#### ~~逾期账户拍买成交(ConfirmExpiredAccountAuction)~~ (deprecated)

当账户**完全到期**后就默认进入到期账户拍卖，以及到期拍卖失败时进行账户回收。

**action 结构**

```
table ActionData {
  action: "confirm_expired_account_auction",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  balance-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell
  BalanceCell {1,}
Outputs:
  AccountCell
  BalanceCell {1,}
```

**约定**

- 此交易的描述中已省略 forcerelay 相关 cell ，但实际执行时首先需要满足 forcerelay 的交易结构，并且验证通过；
- 拍卖金额由 ETH 链的合约进行收取，CKB 链不再验证；
- ETH 交易中的 `to` 字段，既收款地址，必须为指定的合约地址；
- ETH 交易中的 `data` 字段中的 `account_id` 参数必须和 `AccountCell.data.id` 字段一致；
- ETH 交易中的 `data` 字段中的 `expired_time` 参数必须和 `AccountCell.data.expired_at` 字段一致；
- ETH 交易的时间戳和 TimeCell 的时间戳相差不能超过 3 天；
- 输入中 AccountCell 必须处于**完全到期**状态，既 `now > AccountCell.expired_at + ConfigCellAccount.expiration_grace_period`；
- 输入中 AccountCell 的 capacity 必须退还给原 owner ，如果遇到黑洞地址允许退还到任意 lock；
- 输出中 AccountCell 的 capacity 必须 `>= ConfigCellAccount.basic_capacity + ConfigCellAccount.prepared_fee_capacity`；
- 输出中 AccountCell 的 owner、manager 地址必须和 ETH 交易中的 `from` 字段，既付款地址，保持一致；
- 输出中 AccountCell 的 records 必须被清空；
- 输出中 AccountCell 的到期时间为当前 TimeCell 时间之后 1 年；

#### 回收逾期账户(RecycleExpiredAccount)

**action 结构**

```
table ActionData {
  action: "recycle_expired_account",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell (n - 1)     // next 指针指向逾期账户的前一个账户
  AccountCell (n)         // 逾期状态的账户
  [SubAccountCell]        // 如果逾期状态的账户已开启子账户那么需要在此回收 SubAccountCell
Outputs:
  AccountCell (n - 1)
  ChangeCell              // 退还给父账户 owner 的 capacity
  [ChangeCell]            // 如果 DAS 的利润多余 61CKB ，那就还应该将这部分利润退还给 DAS
```

** 约定 **

- 如果子账户功能已开启，那么子账户的回收为必选项；
- 账户必须处于 Normal, LockedForCrossChain 状态，如果是处于 Selling, Auction 状态，那么应当通过 `force_recover_account_status` 交易还原账户状态；
- 回收时需要修改 next 指针指向当前 AccountCell(n) 的前一个 AccountCell(n - 1) ，使 AccountCell(n - 1) 继承当前 AccountCell(n).next 指针；
- AccountCell(n) 被回收后其剩余 capacity 需要退回 owner lock ，其中可以取出小于等于 `ConfigCellAccount.common_fee` 的金额作为交易手续费；
- SubAccountCell 的 capacity 包含基础存储费、手续费、DAS 的利润、父账户的 owner 利润 4 个部分，因此回收 SubAccountCell 时遵循以下规则退还 capacity：
  - DAS 的利润多于 61CKB 的情况下需要退还给 DAS，不足 61CKB 的情况下可以由交易构造者取走；
  - 除 DAS 的利润以外的部分，全部退还给父账户的 owner lock；


## 用户相关交易

### 注册相关交易

#### 申请注册账户(ApplyRegister)

这是整个注册流程中的第一笔交易，为了防止用户期望注册的账户名被抢注，因此这笔交易中只需提供 hash 后的账户名。

输出中的 ApplyRegisterCell 就是凭证，必须等待一定的区块高度后才能拿着它进行下一步的预注册，所需等待的区块数可以从 `ConfigCellApply.apply_min_waiting_block_number` 中获取。

本交易属于 `apply_register` 交易的第二个版本，主要的改进在使用 header_deps 来获取时间及区块信息，因此 ApplyRegisterCell 的 data 只需要包含 32 bytes 的 hash 即可。

**action 结构**

```
table ActionData {
  action: "apply_register",
  params: [],
}
```

**交易结构**

```
CellDeps:
  apply-register-cell-type
  ConfigCellMain
  ConfigCellApply
Inputs:
  FeeCell
Outputs:
  ApplyRegisterCell
  [ChangeCell]
```

#### 申请注册退款(RefundApply)

对于链上未使用的 ApplyRegisterCell 可以进行批量退款。

> 由于 ApplyRegisterCell 可以使用任意 lock script ，因此使用用户自己的 lock script 创建的 ApplyRegisterCell 需要用户签名后才能发起此交易。

**action 结构**

```
table ActionData {
  action: "refund_apply",
  params: [],
}
```

**交易结构**

```
HeaderDeps:
  block_hash(ApplyRegisterCell {1,})
CellDeps:
  apply-register-cell-type
  ConfigCellMain
  ConfigCellApply
Inputs:
  ApplyRegisterCell {1,}
Outputs:
  ChangeCell
```

**约定**

- 一笔交易中可以同时退款多个 ApplyRegisterCell ，但是这些 ApplyRegisterCell 必须使用相同的 lock ；
- ApplyRegisterCell 必须以**区块高度**和 `ConfigCellApply.apply_max_waiting_block_number` 作为相对值，**设置 since 后才可以进行退款**；
- 退款时可以从每一个 ApplyRegisterCell 中取出 100_000_000 shannon 作为交易手续费；

#### 预注册账户(PreRegister)

这是整个注册流程中的第二笔交易，用户需要在这笔交易中提供期账户的明文并支付注册费。作为输入的 ApplyRegisterCell 必须等待 n 个区块且不能等待超过 m 个区块。n 可以从 `ConfigCellApply.apply_min_waiting_block_number` 中获取，m 可以从 `ConfigCellApply.apply_max_waiting_block_number` 中获取。

另一个必须注意的是这笔交易需要包含

**action 结构**

```
table ActionData {
  action: "pre_register",
  params: [],
}
```

**交易结构**

```
HeaderDeps:
  block_hash(ApplyRegisterCell)
CellDeps:
  always-success
  apply-register-cell-type
  pre-account-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellMain
  ConfigCellRelease
  ConfigCellAccount
  ConfigCellApply
  ConfigCellPrice
  ConfigCellPreservedAccountXX
  ConfigCellUnAvailableAccount
  ConfigCellRecordKeyNamespace
  ConfigCellCharSetXxxx {1,}
  AccountCell (n - 1)
Inputs:
  ApplyRegisterCell
  {FeeCell}
Outputs:
  PreAccountCell (n)
  {ChangeCell}
```

**ConfigCellPreservedAccountXX**

ConfigCellPreservedAccountXX 存在 ConfigCellPreservedAccount00 ～ ConfigCellPreservedAccount19 总共 20 个，它们的用途是存放受保护的账户名。受限于 CKB 的 lock script 对 `transaction.witnesses` 字段的体积限制，所以进行了拆分，使用时只需选择其中正确的一个即可。选择的方法如下：

- 去掉账户名的 `.bit` 后缀，并进行 hash；
- 取 hash 的第一个字节，将它转为一个 u8 整型的数字；
- 用上面得到的数字对 20 取模；
- 根据取模得到的结果选择对应尾号的 ConfigCellPreservedAccountXX；

**ConfigCellCharSetXxxx**

ConfigCellCharSetXxxx 存在的数量并不固定，它们的作用是保存 DAS 支持的字符集，同样是受限于 `transaction.witnesses` 字段的体积限制所以做了拆分。使用时只需选择其中正确的一个即可，选择方法如下：

- 解析 PreAccountCell 的 witness ，遍历 `account` 字段；
- `account` 字段中的每一个元素为 `AccountChar` 类型，其 `char_set_name` 字段为**字符集 ID**；
- 将字符集 ID 加上 `100000` 后就可以得到 ConfigCellCharSetXxxx 对应的 **Config ID**；
- 最后就可以根据这些 Config ID 一个或多个 ConfigCellCharSetXxxx；

> 关于 **字符集 ID** 和 **Config ID** 详见 [Cell 结构协议](Cell-结构协议.md) 。

**AccountCell (n - 1)**

这是当前账户在账户链中的前一个 AccountCell 。因为每个 AccountCell.data.id 指明了当前账户的 ID ，AccountCell.data.next 指明了当前账户的下一个已注册账户的 ID ，因此如果计算 PreAccountCell 中账户的 ID 应该排序在 AccountCell.data.id 和 AccountCell.data.next 之间，那么就说明 PreAccountCell 创建时该账户确实未存在于链上。从而可以防止通过脚本提前创建 PreAccountCell 进行账户抢注的行为。

#### 预注册退款(RefundPreRegister)

对于链上未抢注成功的 PreAccountCell 可以进行批量退款。

**action 结构**

```
table ActionData {
  action: "refund_pre_register",
  params: [],
}
```

**交易结构**

```
HeaderDeps:
  block_hash(PreAccountCell {1,})
CellDeps:
  ConfigCellMain
Inputs:
  PreAccountCell {1,}
  [AnyCell] // with PreAccountCell.witness.refund_lock
Outputs:
  ChangeCell
```

**约定**

- 一笔交易中可以同时退款多个 PreAccountCell ，但是这些 PreAccountCell 必须属于同一个 refund_lock；
- PreAccountCell 按照以下要求设置 since 之后才可以进行退款：
  - 一般情况下，since 必须设置为以**时间戳和 86400 秒作为相对值**；
  - 当 inputs 中有一个 cell 使用了和 PreAccountCell.witness.refund_lock 一致的 lock 时，since 必须设置为以**时间戳和 3600 秒作为相对值**；
- 退款只能存放在一个 cell 中，不能分为多个 cell 存放；
- 退款时可以从每一个 PreAccountCell 中取出 10000 shannon 作为交易手续费；

### 账户管理相关交易

所有的账户管理相关交易的 `ActionData` 中多了一个 `permission` 参数，此参数表明了当前交易所需权限，并会被 account-cell-type 以及 das-lock 两个合约脚本共同检查，所以必须正确填写。`permission` 可选的值有：

- 0x00 表示此交易需要 owner 权限；
- 0x01 表明此交易需要 manager 权限；

> 账户的 owner 权限和 manager 权限是互斥的，即要求 manager 权限的操作 owner 也是无权执行的。

> 账户进入宽限期后不能执行除了[账户续期](#账户续期)以外的任何交易。

#### 账户转让(TransferAccount)

用户可以通过此交易将 AccountCell 转给他人，即永久转移账户的所有权。交易执行后会修改 AccountCell 的 `lock.args` 字段，并且要求输出中的 AccountCell 的 `lock.args` 中 owner 和 manager 必须是相同的 lock hash ，因为账户转移给他人后 manager 仍然归属原用户可能导致潜在的风险。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.transfer_account_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.transfer_account_fee` 获取。

**action 结构**

```
table ActionData {
  action: "transfer_account",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 修改管理员(EditManager)

用户通过这笔交易可以指定他人才有账户记录的修改权限。交易执行后会修改 AccountCell 的 `lock.args` 字段，并要求输出中的 AccountCell 的 `lock.args` 的 manager 的部分必须和输入中不同。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.edit_manager_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.edit_manager_fee` 中获取。

**action 结构**

```
table ActionData {
  action: "edit_manager",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellMain
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 修改记录(EditRecords)

这里修改的是账户的记录，是一个账户在日常使用中最频繁读取的信息。交易执行后会修改 AccountCell 的 `witness.records` 中存放的信息。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.edit_records_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.edit_records_fee` 中获取。

> 因为前面已经提到过 owner 权限和 manager 权限是互斥的，所以**修改记录的权限仅 manager 才有**。

**action 结构**

```
table ActionData {
  action: "edit_records",
  params: [0x01],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
  ConfigCellRecordKeyNamespace
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 账户续期(RenewAccount)

每个账户对应的 AccountCell 都在 `data` 中存放了到期时间，想要延长此到期时间的唯一方法就是执行这笔交易。交易执行后会修改 AccountCell 的 `data` 中存放的到期时间为最新值，具体数值取决于字符的费用多少，但是最少不能少于一年。

> 任何人都可以为任何账户名续费，合约不会验证资金来源。

**action 结构**

```
table ActionData {
  action: "renew_account",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  income-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellMain
  ConfigCellPrice
  ConfigCellAccount
Inputs:
  AccountCell
  [IncomeCell] // 如果续费金额不足 IncomeCell 存储费，那么就可以在输入中放入一个空的 IncomeCell
  FeeCell // 用户需要通过一个 NormalCell 来支付费用
Outputs:
  AccountCell
  IncomeCell // 用于存放用户支付的费用
  [ChangeCell]
```

### 反向解析相关交易 V2

#### 创建反向解析 SMT 树(CreateReverseRecordRoot)

该交易可以创建一颗存放反向解析 SMT 树根的 Cell ，也就是创建 ReverseRecordRootCell 。

**action 结构**

```
table ActionData {
  action: "create_reverse_record_root",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  balance-cell-type
  reverse-record-root-cell-type
  ConfigCellMain
  ConfigCellReverseResolution
Inputs:
  BalanceCell {1,}
Outputs:
  ReverseRecordRootCell {1,}
  BalanceCell {1,}
```

**约定**

- inputs 中 BalanceCell 必须有至少一个使用了 super lock 。
- outputs 中必须创建一个 Root 为空(0x0000000000000000000000000000000000000000000000000000000000000000)的 ReverseRecordRootCell 。
- ReverseRecordRootCell 的 lock 必须为 `always-success` 。

#### 更新反向解析(UpdateReverseRecordRoot)

该交易可以创建、编辑、删除一个公钥对应的反向解析记录。

**action 结构**

```
table ActionData {
  action: "update_reverse_record_root",
  params: [],
}
```

**交易结构**

```
HeaderDeps:
  block_hash(ReverseRecordRootCell)
CellDeps:
  das-lock
  balance-cell-type
  reverse-record-root-cell-type
  ConfigCellMain
  ConfigCellReverseResolution
  ConfigCellSMTNodeWhitelist
Inputs:
  ReverseRecordRootCell
  BalanceCell {1,}
Outputs:
  ReverseRecordRootCell
  BalanceCell {1,}
```

**约定**

- ReverseRecordRootCell 必须前后一致，只有 outputs_data 中的 SMT Root 必须不同；
- inputs 的 BalanceCell 中必须至少有一个的 lock 存在于 ConfigCellSMTNodeWhitelist 中；
- witness 中对 SMT 的操作记录必须按照从旧到新的顺序依序排列，每一条记录也就是对 Root 的一次更新，更新必须依序进行；

### 二级市场相关交易

#### 一口价交易

##### 开始出售(StartAccountSale)

该交易可以将可以账户标记为出售状态，交易会创建一个 AccountSaleCell ，其中存放了售价等相关信息，但是售价不得低于 `ConfigCellSecondaryMarket.min_sale_price` 。

**action 结构**

```
table ActionData {
  action: "start_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
Inputs:
  AccountCell
  BalanceCell {1,}
Outputs:
  AccountCell
  AccountSaleCell
  [BalanceCell]
```

**约定**

- AccountCell 和 AccountSaleCell 的 lock 必须一致，并且是 das-lock ；
- AccountSaleCell 的 capacity 需要等于 `ConfigCellSecondaryMarket.sale_cell_basic_capacity + ConfigCellSecondaryMarket.sale_cell_prepared_fee_capacity`
- AccountSaleCell 需要遵守其他 `ConfigCellSecondaryMarket.sale_*` 配置项的限制；

##### 修改商品信息(EditAccountSale)

该交易可以修改存放在 AccountSaleCell 中的售价等信息。

**action 结构**

```
table ActionData {
  action: "edit_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellSecondaryMarket
  AccountCell
Inputs:
  AccountSaleCell
Outputs:
  AccountSaleCell
```

**约定**

- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；

##### 取消出售(CancelAccountSale)

只要账户未被售出，就可以通过此交易取消账户的一口价出售。

**action 结构**

```
table ActionData {
  action: "cancel_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
Inputs:
  AccountCell
  AccountSaleCell
Outputs:
  AccountCell
  BalanceCell
```

**约定**

- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 交易手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- 必须存在一个包含 AccountSaleCell 退款的 ChangeCell ；

##### 购买账户(BuyAccount)

其他用户可以通过这笔交易购买出售中的账户，购买成功账户就转移到新账户名下，原有的解析记录都会被清空。

**action 结构**

```
table ActionData {
  action: "buy_account",
  params: [inviter_lock, channel_lock, 0x00],
}
```

- inviter_lock ，如果购买账号的用户有邀请人，可以通过此参数传递邀请人信息，即一个 molecule 编码的 Script 结构，没有邀请人时需要传入 Script 结构的默认值；
- channel_lock ，购买渠道可以通过此参数填入自己的收款地址来收取分成，同样必须是一个 molecule 编码的 Script 结构；

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellIncome
  ConfigCellSecondaryMarket
Inputs:
  AccountCell
  AccountSaleCell
  BalanceCell {1,}
Outputs:
  AccountCell
  IncomeCell // 存放分配给 inviter_lock 和 channel_lock 的利润
  BalanceCell // AccountSaleCell 的 capacity 必须以使用 das-lock 的 NormalCell 形式退还给账户的出售者
```

**约定**

- inviter_lock 和 channel_lock 如果为 Script 结构的默认值，就视为没有邀请人，没有渠道商；
- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 交易手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- inviter, channel, DAS 三个角色的利润需要存放在 IncomeCell 中，seller 的利润需要存放在一个 NormalCell 中；
- 可以在这笔交易交易中直接创建 IncomeCell，IncomeCell 需要满足以下约束：
  - 记录总金额必须和 IncomeCell.capacity 相等；
  - 如果 invitor、chanenl、DAS 的 lock script 相同，那么他们的利润相关记录必须合并；
  - 其他记录不能和利润相关记录合并；
  - 总记录数必须少于等于 `ConfigCellIncome.max_records`；

#### 报价交易

##### 创建报价(MakeOffer)

任何用户都可以对任意的 DAS 账户进行主动的报价。

**action 结构**

```
table ActionData {
  action: "make_offer",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  offer-cell-type
  ConfigCellSecondaryMarket
Inputs:
  BalanceCell {1,}
Outputs:
  OfferCell
  [BalanceCell] {1,}
```

**约定**

- 输入中所有 BalanceCell 的 lock 必须一致，并且是 das-lock；
- OfferCell 的 lock 必须和输入中的 BalanceCell 一致，并且是 das-lock；
- OfferCell 的 capacity 需要大于 `ConfigCellSecondaryMarket.offer_cell_basic_capacity + ConfigCellSecondaryMarket.offer_cell_prepared_fee_capacity`；
- 并且 OfferCell 的 capacity 需要大于等于 `OfferCell.price` 且小于等于 `OfferCell.price + ConfigCellSecondaryMarket.offer_cell_prepared_fee_capacity`；
- OfferCell 需要遵守其他 `ConfigCellSecondaryMarket.offer_*` 配置项的限制；
- 邀请人信息直接存放在 OfferCell 的 inviter_lock 和 channel_lock 字段中，如果这些字段为 Script 结构的默认值，就视为没有邀请人，没有渠道商；

##### 修改报价(EditOffer)

**action 结构**

```
table ActionData {
  action: "edit_offer",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  offer-cell-type
  ConfigCellSecondaryMarket
Inputs:
  OfferCell
  [BalanceCell] {1,}
Outputs:
  OfferCell
  [BalanceCell] {1,}
```

**约定**

- 只能修改 OfferCell 的 price 和 message 字段；
- 交易手续费可以从 OfferCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- 当 price 变化时可以按需填充/提取其中的 capacity ，同时需要兼顾 BalanceCell 的最小找零额等限制；

##### 取消报价(CancelOffer)

用户的报价单只要没有被接受，就可以在任意时刻取消。

**action 结构**

```
table ActionData {
  action: "cancel_offer",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  offer-cell-type
  TimeCell
  ConfigCellSecondaryMarket
Inputs:
  OfferCell {1,}
Outputs:
  BalanceCell {1,}
```

**约定**

- 用户可以一次性撤消一个或多个 OfferCell ；
- 交易手续费可以从 OfferCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- 输出中 BalanceCell 的总额应该大于等于输入中 OfferCell 的总额减去 `ConfigCellSecondaryMarket.common_fee`；

##### 接受报价(AcceptOffer)

持有报价对应的 DAS 账户的用户可以在账户过期前接受报价。

**action 结构**

```
table ActionData {
  action: "accept_offer",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  ConfigCellAccount
  ConfigCellIncome
  ConfigCellProfitRate
  ConfigCellSecondaryMarket
Inputs:
  OfferCell
  AccountCell
Outputs:
  AccountCell
  IncomeCell // 存放分配给 inviter_lock 和 channel_lock 的利润
  BalanceCell {1,} // 分配给 Seller 的利润
```

**约定**

- AccountCell 需要和 OfferCell 拥有完全一样的 account ；
- 交易手续费可以从 OfferCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- OfferCell 中剩余的交易手续费不用退还给 buyer ；
- inviter, channel, DAS 三个角色的利润需要存放在 IncomeCell 中，seller 的利润需要存放在一个 NormalCell 中；
- 可以在这笔交易交易中直接创建 IncomeCell，IncomeCell 需要满足以下约束：
  - 记录总金额必须和 IncomeCell.capacity 相等；
  - 如果 invitor、chanenl、DAS 的 lock script 相同，那么他们的利润相关记录必须合并；
  - 其他记录不能和利润相关记录合并；
  - 总记录数必须少于等于 `ConfigCellIncome.max_records`；

#### 账户竞拍

##### 开始竞拍（StartAccountAuction）

同时支持 Fomo 和普通竞拍：

- Fomo 竞拍 AccountAuctionCell.prev_bidder_profit_rate 不为 0；
- 普通竞拍时只需要将 AccountAuctionCell.prev_bidder_profit_rate 设为 0 即可。

> 竞拍一旦有人出价，就不能中止，必须等到时间结束后成交。

**action 结构**

```
table ActionData {
    action: "start_account_auction",
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-auction-cell-type
  TimeCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  AccountAuctionCell
  [ChangeCell]
```

##### 修改竞拍信息（EditAccountAuction）

该交易可以修改存放在 AccountAuctionCell 中的起拍价/描述等信息，分为**可随时修改**和**无人出价前可以修改**两类信息：

- **可随时修改**包括：描述；
- **无人出价前可以修改**包括：起拍价(opening_price)、每次加价的最低比例(increment_rate_each_bid)、起拍时间(started_at)、前一个竞拍者的利润率(prev_bidder_profit_rate)

**action 结构**

```
table ActionData {
    action: "edit_account_auction",
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
    das-lock
    account-aution-cell-type
    TimeCell
    HeightCell
    ConfigCellSecondaryMarket
Inputs:
    AccountAuctionCell
    [FeeCell]
Outputs:
    AccountAuctionCell
    [ChangeCell]
```

##### 取消出售（CancelAccountAuction）

只有在无人出价的时候，才可以通过该 action 取消拍卖。

**action 结构**

```
table ActionData {
    action: "cancel_account_auction",
    params: [0x00]
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-auction-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
Inputs:
  AccountCell
  AccountAuctionCell
Outputs:
  AccountCell
  [ChangeCell]
```

##### 出价（BidAccountAuction）

出价竞拍指定账户。

**action 结构**

```
table ActionData {
    action: "bid_account_auction",
    params: [inviter_lock, channel_lock]
}
```

- inviter_lock ，如果竞拍账号的用户有邀请人，可以通过此参数传递邀请人信息，即一个 molecule 编码的 Script 结构，没有邀请人时需要传入 Script 结构的默认值；
- channel_lock ，购买渠道可以通过此参数填入自己的收款地址来收取分成，同样必须是一个 molecule 编码的 Script 结构；

**交易结构**

```
CellDeps:
  das-lock
  offer-cell-type
  account-cell-type
  eip712-lib
  account-auction-cell-type
  TimeCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
  AccountCell
Inputs:
  AccountAuctionCell
  FeeCell
  [IncomeCell] // 如果待分配给 inviter_lock 和 channel_lock 的利润不足 IncomeCell 存储费，那么可以在输入中放入一个空 IncomeCell
Outputs:
  AccountAuctionCell
  [IncomeCell] // 存放分配给 inviter_lock 和 channel_lock 的利润
  [ChangeCell] // AccountSaleCell 的 capacity 必须退还给账户的出售者 das-lock normal cell
```

##### 确认竞拍（ConfirmAccountAuction）

竞拍到期，最新的出价人可以确认竞拍状态，获得竞拍的账号

**action 结构**

```
table ActionData {
    action: "confirm_account_auction"
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  account-auction-cell-type
  TimeCell
  ConfigCellAccount
  ConfigCellAuction
Inputs:
  AccountCell
  AccountAuctionCell
Outputs:
  AccountCell
  ChangeCell // 拍卖方获得竞拍所得
```

### 到期账户拍卖相关交易

账户到期后的拍卖目前主要在 ETH 进行，由多个 Keeper 节点确认竞拍结果后，即可在 CKB 链通过多签发起竞拍结果确认交易。

#### 确认到期账户拍卖结果（ConfirmExpiredAccountAuction）

当账户在其他链上拍卖成功后，如果跨链节点检测到账户在其他链已销毁，就可以通过多签在 ckb 链转移该账户的所有权。

**action 结构**

```
table ActionData {
    action: "confirm_expired_account_auction"
    params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  ConfigCellMain
  ConfigCellAccount
  [ConfigCellSubAccount] // 只有存在 SubAccountCell 时才需要
Inputs:
  AccountCell
  [SubAccountCell] // 只有 AccountCell.witness.enable_sub_account 为 true 时才需要
Outputs:
  AccountCell
  [SubAccountCell]
```

**约定**

- AccountCell 必须处于 normal 状态；
- AccountCell 的解析记录必须被清空；
- 如果 AccountCell 开启了子账户，那么 SubAccountCell 应该被保留下来；
- 如果 AccountCell 开启了子账户，那么子账户中的原 owner 的利润和 DAS 的利润必须被退还；
- 如果 SubAccountCell 中的 capacity 和 owner 的利润和 DAS 的利润不一致时，合约会要求按照记录的利润进行退款，是否执行又交易的构造者自行决定；

### 子账户相关交易 v2

#### 启用子账户(EnableSubAccount)

该交易可以启用子账户功能。

**action 结构**

```
table ActionData {
  action: "enable_sub_account",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  sub-account-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSubAccount
Inputs:
  AccountCell
  BalanceCell {1,}
Outputs:
  AccountCell    // AccountCell.enable_sub_account 需要被设为 1
  SubAccountCell // 创建 SubAccountCell 用于存放子账户的默克尔根
  [BalanceCell]
```

**约定**

- AccountCell.enable_sub_account 必须为 0 未启用的账户才可发起此交易；
- SubAccountCell 的 capacity 需要等于 `ConfigCellSubAccount.basic_capacity + ConfigCellSubAccount.prepared_fee_capacity` ；
- SubAccountCell 的 `data` 需要设为 `data.flag = 0xff` 状态，对应状态的其他要求详见 [SubAccountCell](Cell-结构协议.md#SubAccountCell)`；

#### 设置子账户创建脚本(ConfigSubAccountCustomScript)

设置子账户创建脚本的 type ID，设置后创建子账户时就不再需要将 AccountCell 放入 inputs ，而是以执行该脚本进行是否通过做为交易验证的标准。 如果已经设置过子账户创建脚本，那么再次执行此交易可以进行脚本 type ID
的更换或者清空，清空子账户创建脚本后，就会将创建流程还原为通过 owner 或 manager 手工创建子账户的方式。

**action 结构**

```
table ActionData {
  action: "config_sub_account_custom_script",
  params: [0x00/0x01], // owner 或 manager 均可设置子账户创建脚本
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  sub-account-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSubAccount
Inputs:
  AccountCell
  SubAccountCell
  BalanceCell {1,}
Outputs:
  AccountCell    // AccountCell 无需任何修改，只是用于验签
  SubAccountCell // 增加自定义创建脚本 type ID ，或者将 type ID 全部重置为 0
  [BalanceCell]
```

**约定**

- owner 或 manager 均有权限配置子账户创建脚本；
- AccountCell 必须未处于**宽限期**或之后的状态；
- 设置子账户创建脚本时，如果 type ID 不为全 0 ，就认为是有效的 type ID ，为全 0 ，就认为是清空 type ID；

#### 设置子账户(ConfigSubAccount)

设置子账户创建脚本的 type ID，设置后创建子账户时就不再需要将 AccountCell 放入 inputs ，而是以执行该脚本进行是否通过做为交易验证的标准。 如果已经设置过子账户创建脚本，那么再次执行此交易可以进行脚本 type ID
的更换或者清空，清空子账户创建脚本后，就会将创建流程还原为通过 owner 或 manager 手工创建子账户的方式。

**action 结构**

```
table ActionData {
  action: "config_sub_account",
  params: [0x00/0x01],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  sub-account-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSubAccount
Inputs:
  AccountCell
  SubAccountCell
  BalanceCell {1,}
Outputs:
  AccountCell    // AccountCell 无需任何修改，只是用于验签
  SubAccountCell
  [BalanceCell]
Witnesses:
  SubAccountPriceRule1
  SubAccountPriceRule2
  SubAccountPriceRule3
  ...
  SubAccountPreservedRule1
  SubAccountPreservedRule2
  SubAccountPreservedRule3
  ...
```

**约定**

- owner 或 manager 均有权限配置子账户创建脚本；
- AccountCell 在交易前后不能发生变化，且必须未处于**宽限期**或之后的状态；
- SubAccountCell 仅能将 `flag` 设置为以下值，对应状态的其他要求详见 [SubAccountCell](Cell-结构协议.md#SubAccountCell)：
  - `0x00` ，指明用户仅使用手工分发；
  - `0xff` ，指明用户启用了基于配置的自动分发特性；
- `SubAccountPriceRule` 必须按照其 index 字段顺序排序；
- `SubAccountPreservedRule` 必须按照其 index 字段顺序排序；
- `SubAccountPriceRule` 和 `SubAccountPreservedRule` 需要必须能够成功通过类型检查；

#### 更新子账户(UpdateSubAccount)

这笔交易容纳了子账户相关的创建、编辑、续费、回收等所有操作，因此除了 `ActionData` 可以用于辨别当前交易外，还需要了解每条子账户 witness ，也就是 SubAccount witness 的含义。

**action 结构**

```
table ActionData {
  action: "update_sub_account",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  sub-account-cell-type
  QuoteCell
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSubAccount
  AccountCell
Inputs:
  SubAccountCell
  [BalanceCell {1,}]
Outputs:
  SubAccountCell // 子账户的默克尔根必须更新到最终状态
  [BalanceCell]
```

**交易约定**

> 这里的约定适用于这笔交易。

- AccountCell 必须未处于**宽限期**或之后的状态；
- 这笔交易可以从 SubAccountCell 中扣除的手续费不得高于 `ConfigCellSubAccount.renew_fee` 中配置值；

##### 创建子账户

**SubAccount witness 结构**

```
version: 3
action: create
signature: null
sign_role: null
sign_expired_at: null
new_root: ...
proof: ...
sub_account: ...
edit_key: "manual" // custom_script, custom_rule
edit_value: ...
```

- 当 `edit_key == manual` 时，`edit_value` 值为 `SubAccountMintSign.account_list_smt_root` 的有效 `proof` ，其要能够证明当前的创建的账户名确实存在于 `SubAccountMintSign.account_list_smt_root` 中；
- 当 `edit_key == custom_script` 时，`edit_value` 必须为空；
- 当 `edit_key == custom_rule` 时，`edit_value` 前 20 Bytes 为渠道商的识别 ID，后 8 Bytes 为此账号注册时所支付的金额；

> 为了支持第三方渠道通过自定义规则分发子账户，因此每个通过第三方渠道注册的子账户的 witness 中需要带上渠道商的识别 ID 和注册金额，后续在 dotbit 团队以此为依据和第三方渠道进行利润分配。
>
> 没有任何第三方渠道时，渠道标识就使用 20 Bytes 的 `0x00` 进行填充，所有利润归属 dotbit 团队。

**约定**

- owner 或 manager 均有权限创建子账户；
- 注册期限最少为 1 年；
- 子账户对应的 `SubAccount.sub_account.expired_at` 必须填入对应的到期时间；
- 当 `SubAccountCell.data.flag == 0x00` 表明：
  - 用户可以通过 `SubAccountMintSign` 指定手工 Mint 的账户列表；
  - 手工 Mint 的子账户的注册费等于 `ConfigCellSubAccount.new_sub_account_price`；
  - `SubAccount.edit_key` 存放 `manual` 的 utf-8 编码数据；
- 当 `SubAccountCell.data.flag == 0x01` 表明：
  - 用户仍然可以通过 `SubAccountMintSign` 指定手工 Mint 的账户列表；
  - 手工 Mint 的子账户的注册费等于 `ConfigCellSubAccount.new_sub_account_price`；
  - 如果是手工 Mint 的子账户，必须携带以下信息：
    - `SubAccount.edit_key` 存放 `manual` 的 utf-8 编码数据；
  - 每个子账户的注册费由自定义脚本约束，注册费需存放于 `SubAccountCell.capacity`，并按照 `ConfigCellSubAccount.new_sub_account_custom_price_das_profit_rate` 分别在 `SubAccountCell.data.das_profit` 和 `SubAccountCell.data.owner_profit` 记录累计后的利润分配额；
  - 如果是根据自定义规则注册的子账户，携带以下信息：
    - `SubAccount.edit_key` 存放 `custom_script` 的 utf-8 编码数据；
  - 所有输入输出的 BalanceCell 只能使用一致的 lock ；
- 当 `SubAccountCell.data.flag == 0xff` 表明：
  - 用户仍然可以通过 `SubAccountMintSign` 指定手工 Mint 的账户列表；
  - 手工 Mint 的子账户的注册费等于 `ConfigCellSubAccount.new_sub_account_price`；
  - 如果是手工 Mint 的子账户，必须携带以下信息：
    - `SubAccount.edit_key` 存放 `manual` 的 utf-8 编码数据；
  - 每个子账户是否可注册根据 `SubAccountPreservedRule` 的执行结果来确定；
  - 可注册的子账户定价根据 `SubAccountPriceRule` 的执行结果来确定；
  - 没有被 `SubAccountPriceRule` 匹配成功的账户也无法注册；
  - 如果是根据自定义规则注册的子账户，携带以下信息：
    - `SubAccount.edit_key` 存放 `custom_rule` 的 utf-8 编码数据；
    - `SubAccount.edit_value` 存放第三方渠道的识别 ID ，以及注册此账户所支付的 CKB 金额；
  - 所有注册费都放入 `SubAccountCell.data.das_profit` 经由统计后再进行分配；

##### 编辑子账户

**SubAccount witness 结构**

```
version: 3
action: edit
signature: ...
sign_role: ...
sign_expired_at: ...
new_root: ...
proof: ...
sub_account: ...
edit_key: "owner" // manager, records
edit_value: ...
```

- `signature` 需要根据编辑的字段提供 owner 或 manager 的签名：
  - `digest` 的生成方式为按顺序拼接以下数据：
  - `from did: ` 字符串的 utf8 bytes；
  - 一个按照 ckb-hash 生成的 hash ，创建方法是按顺序拼接以下字段后进行 hash：
    - `account_id`
    - `edit_key`
    - `edit_value`
    - `nonce`
    - `sign_expired_at`
- `sign_role` 用于指明 `signature` 来自 owner 还是 manager ；
- `sign_expired_at` 为防止 `signature` 被重放而设计的字段，其时间戳必须小于等于主账户即交易中所有子账户的 `expired_at` ；
- 当 `edit_key == owner` 时，`edit_value` 必须为一个合法的 das-lock 的 args 数据，并且出于安全考虑，子账户的 records 字段应该被清空；
- 当 `edit_key == manager` 时，`edit_value` 必须为一个合法的 das-lock 的 args 数据；
- 当 `edit_key == records` 时，`edit_value` 必须为一个 molecule 编码的 `Records` 类型数据；

**约定**

- 当前时间如果已经超过了 `SubAccount.expired_at`，则该子账户不再可以编辑；
- 必须通过 `edit_key, edit_value` 明确编辑的字段名和值；

##### 续费子账户

**SubAccount witness 结构**

```
version: 3
action: renew
signature: null
sign_role: null
sign_expired_at: null
new_root: ...
proof: ...
sub_account: ...
edit_key: "manual" // custom_script, custom_rule
edit_value: ...
```

- 无论何种情况 `edit_value` 的前 8 bytes 总是存放续费后的新到期时间；
- 当 `edit_key == manual` 时：
  - 如果是 owner/manager 主动续费，`edit_value` 的值除了 8 bytes 的到期时间外，还要存放 `SubAccountRenewSign.account_list_smt_root` 的有效 `proof` 户名确实存在于 `SubAccountRenewSign.account_list_smt_root` 中；
  - 如果是他人续费，`edit_value` 的值只需要 8 bytes 的到期时间；
- 当 `edit_key == custom_rule` 时，`edit_value` 的值除了 8 bytes 的到期时间外，还有 20 Bytes 为渠道商的识别 ID ，以及 8 Bytes 为此账号注册时所支付的金额；
- `edit_key == custom_script` 为不再被支持的情况，未来将会删除；

**约定**

- 续费期限最少为 1 年；
- 一笔交易中只存在一个 `SubAccountRenewSign` ，其只能属于 owner 、manager 或 other 之一；
- 无论 `SubAccountCell.data.flag` 为任何值：
  - owner 或 manager 总是可以通过 `SubAccountRenewSign` 指定手工续费的账户列表；
  - `SubAccountRenewSign.signature` 必须由 type 调用 cell_deps 中 `AccountCell.lock` 进行验签并通过；
  - 可以使用 BalanceCell 或者 NormalCell 进行支付，如果使用 BalanceCell 进行支付只能使用相同 owner lock 或 manager lock 的 BalanceCell；
  - 手工续费时每个子账户的续费价格等于 `ConfigCellSubAccount.renew_sub_account_price`；
  - 手工续费的子账户，必须携带以下信息：
    - `SubAccount.edit_key` 存放 `manual` 的 utf-8 编码数据；
    - `SubAccount.edit_value` 前 8 bytes 存放新的 expired_at 时间戳，后续字节填充 SubAccountRenewSign 对应的 proof；
- 当 `SubAccountCell.data.flag == 0x00` 表明：
  - 子账户只能进行手工续费；
  - 因为续费费用都一样，子账户用户也可以采用下面最下面自行续费的方式进行续费；
- 当 `SubAccountCell.data.flag == 0xff` 表明：
  - 只能使用 NormalCell 进行支付；
  - 续费价格根据 `SubAccountPriceRule` 的执行结果来确定；
  - 根据自定义规则续费的子账户，必须携带以下信息：
    - `SubAccount.edit_key` 存放 `custom_rule` 的 utf-8 编码数据；
    - `SubAccount.edit_value` 前 8 bytes 存放新的 expired_at 时间戳，后续的 bytes 存放第三方渠道的识别 ID ，以及续费所支付的 CKB 金额；
  - 所有注册费都放入 `SubAccountCell.data.das_profit` 经由统计后再进行分配；
  - 为了避免子账户用户绕过自定义价格进行续费，仅当子账户无法匹配任何价格时，子账户用户也可以采用下面最下面自行续费的方式进行续费；
- 当以上续费规则都无法匹配子账户时，子账户用户也可以进行自行续费：
  - 只能使用 NormalCell 进行支付；
  - 续费价格等于 `ConfigCellSubAccount.renew_sub_account_price`；
  - 被续费的子账户，必须携带以下信息：
    - `SubAccount.edit_key` 存放 `manual` 的 utf-8 编码数据；
    - `SubAccount.edit_value` 前 8 bytes 存放新的 expired_at 时间戳；

##### 回收子账户

当子账户过期时，任何人都可以通过此交易回收子账户。

**action**

```
version: 3
action: recycle
signature: null
sign_role: null
sign_expired_at: null
new_root: ...
proof: ...
sub_account: ...
edit_key: null
edit_value: null
```

**约定**

- 当子账户到期并经过 `ConfigCellAccount.expiration_grace_period` 的宽限期后，才可以进行回收；
- `witness.new_root` 和 `witness.proof` 应该能够证明当前子账户在 SMT 中的 value 为空，即 32 bytes 的 `0x00`;

#### 提取子账户利润(CollectSubAccountProfit)

子账户的 capacity 中存放了 DAS 和 owner 的利润，需要提取利润时就需要发起此交易。

**action 结构**

```
table ActionData {
  action: "collect_sub_account_profit",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  sub-account-cell-type
  balance-cell-type
  ConfigCellSubAccount
  AccountCell
Inputs:
  SubAccountCell
Outputs:
  SubAccountCell
  ChangeCell // DAS 的利润
  ChangeCell // owner 的利润
```

**约定**

- cell_deps 中的 AccountCell 和 SubAccountCell 的 account ID 必须一致；
- 无论 AccountCell 为任何状态，都可以进行利润提取；
- 任何人可以发起此交易提取利润，但是除非输入中包含 dotbit 官方的特定 lock ，否则只能提取 owner 的利润到 owner 的地址；
- SubAccountCell 中 DAS 或 owner 任意一方的利润大于等于 61CKB 时就可以发起此交易提取利润；
- 提取时必须将 owner 的所有可提取的 CKB 全部提出，并将 `owner_profit` 记录置为 0；
- 这笔交易可以从 SubAccountCell 中扣除的手续费不得高于 `ConfigCellSubAccount.common_fee` 中配置值；

#### 提取子账户第三方渠道利润(CollectSubAccountChannelProfit)

和上一笔 `collect_sub_account_profit` 交易不同，这笔交易为仅限 dotbit 能够发起的，提取利润分配给第三方渠道的交易：

**action 结构**

```
table ActionData {
  action: "collect_sub_account_channel_profit",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  sub-account-cell-type
  balance-cell-type
  ConfigCellSubAccount
Inputs:
  SubAccountCell
  NormalCell
Outputs:
  SubAccountCell
  ChangeCell // 渠道商 1 的利润
  ChangeCell // 渠道商 2 的利润
```

**约定**

- 输入中必须有一个包含 dotbit 官方特定 lock 的 NormalCell 进行验证；

### 设备管理相关交易

#### 创建 DeviceKeyListCell （CreateDeviceKeyList)

创建 DeviceKeyListCell 用于存储设备管理时，各设备验签用的 DeviceKeyList。

**Action 结构**

```C
table ActionData {
  action: "create_device_key_list",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  ConfigCellMain
  device-key-list-cell-type

Inputs:
  BalanceCell

Outputs:
  DeviceKeyListCell
  [BalanceCell]
```

**约定**

- 任何人都可以创建 DeviceKeyListCell；
- DeviceKeyListCell 的 das-lock 的 args 中，owner 和 manager 必须相同，等于 DeviceKeyList 中的 DeviceKey；
- input 中 BalanceCell 和 outputs 中 BalanceCell 的 lock 需要一致；
- witness 必须有 DeviceKeyList ，而且该数组有且仅有一个 DeviceKey；
- 合约不对交易中 DeviceKey 的正确性进行校验；

#### 更新 DeviceKeyListCell (UpdateDeviceKeyList)

用交易里新的 DeviceKeyList 替换 DeviceKeyListCell 里旧的。

**Action 结构**

```
table ActionData {
  action: "update_device_key_list",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  ConfigCellMain
  device-key-list-cell-type
Inputs:
  DeviceKeyListCell
Outputs:
  DeviceKeyListCell
```

**约定**

- 更新操作包含增加或删除操作；
- 每次只能新增或者删除一个设备；
- UpdateDeviceKeyList 操作中，DeviceKeyList 容量下限是 1，容量上限是 10；

#### 删除 DeviceKeyListCell (DestroyDeviceKeyList)

当用户选择放弃设备管理时，会清空列表，释放 cell，并把ckb退回给 DeviceKeyListCell.witness.refund_lock；

**action 结构**

```
table ActionData {
  action: "destroy_device_key_list",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  device-key-list-cell-type
Inputs:
  DeviceKeyListCell {1,}
Outputs:
  BalanceCell
```

**约定**

- 退款时，该 cell 占用的 ckb 会退款到 DeviceKeyListCell 中指定的 refund_lock。 这个 refund_lock 和创建 DeviceKeyListCell 时提供 ckb 的BalanceCell 的 lock 一致。

### 授权相关交易

目前所有的授权交易都采用了以下相同的数据结构：

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell
Outputs:
  AccountCell
```

#### 创建授权交易(CreateApproval)

**action 结构**

```
table ActionData {
  action: "create_approval",
  params: [0x00],
}
```

**交易结构**

为上述公共结构

**约定**

- 交易手续费可以由 AccountCell 支付，但是支付额度上限不能超过 ConfigCellAccount.common_fee 的值；
- 满足 [各类型 approval 的具体约束](approval/basic-structure.md) ；

#### 延长授权交易(DelayApproval)

**action 结构**

```
table ActionData {
  action: "delay_approval",
  params: [0x00],
}
```

**交易结构**

为上述公共结构

**约定**

- 交易手续费可以由 AccountCell 支付，但是支付额度上限不能超过 ConfigCellAccount.common_fee 的值；
- 满足 [各类型 approval 的具体约束](approval/basic-structure.md) ；

#### 取消授权交易(RevokeApproval)

**action 结构**

```
table ActionData {
  action: "revoke_approval",
  params: [0x00],
}
```

**交易结构**

为上述公共结构

**约定**

- 交易手续费可以由 AccountCell 支付，但是支付额度上限不能超过 ConfigCellAccount.common_fee 的值；
- 满足 [各类型 approval 的具体约束](approval/basic-structure.md) ；

#### 执行授权交易(FulFillApproval)

**action 结构**

```
table ActionData {
  action: "fulfill_approval",
  params: [null/0x00],
}
```

**交易结构**

为上述公共结构

**约定**

- 交易手续费可以由 AccountCell 支付，但是支付额度上限不能超过 ConfigCellAccount.common_fee 的值；
- 满足 [各类型 approval 的具体约束](approval/basic-structure.md) ；
### DIDPoint 相关交易
DID Point 是 .bit 团队推出的，锚定美元的积分。用户通过一些方式充值到 .bit 后获得对应金额的 DID Point。之后可以使用它购买、续费 .bit 账户。

术语约定
- 存在于 ConfigCellDPoint.transfer_whitelist 中的 lock ，以下统一称为`转账 lock`；
- 存在于 ConfigCellDPoint.capacity_recycle_whitelist 中的 lock 统一称为 `回收 lock`；
- 除了上两种以外的 lock ，统一称为 `用户 lock` ；
#### 铸造 DIDPoint (MintDp)

**Action 结构**

```
table ActionData {
  action: "mint_dp",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  dpoint-cell-type
  ConfigCellMain
  ConfigCellDPoint
Inputs:
  NormalCell {1, }
Outputs:
  DPointCell {1, }
  ChangeCell 
```

**约定**
- inputs 中必须包含至少一个使用 super lock 的 cell ；
- outputs 中必须包含至少一个 DPointCell ；
- outputs 中的 DPointCell.capacity 必须为 ConfigCellDPoint.basic_capacity + ConfigCellDPoint.prepared_fee_capacity 之和；
- outputs 中的 DPointCell.lock 必须全部为 `转账 lock`；
- 
#### 转账 DIDPoint (TransferDp)


**Action 结构**

```
table ActionData {
  action: "transfer_dp",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  eip712-lib
  dpoint-cell-type
  ConfigCellMain
  ConfigCellDPoint
Inputs:
  DPointCell {1, } [A]
Outputs:
  DPointCell {1, } [A]
```

**约定**
- inputs 中的 DPointCells.lock 只能为同一 lock ，即单个 `用户 lock` 或单个 `转账 lock` ；
- inputs 或 outputs 中只能有来自同一用户的 `用户 lock` ；
- inputs 或 outputs 中必须至少有一个 `转账 lock`；
- inputs 中的 DPoint 总额等于 outputs 中的 DPoint 总额；
- 此交易的手续费必须由其他 cell 进行支付；
- 
#### 销毁 DIDPoint (BurnDp)


**Action 结构**

```
table ActionData {
  action: "burn_dp",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  eip712-lib
  dpoint-cell-type
  ConfigCellMain
  ConfigCellDPoint
Inputs:
  DPointCell {1, } [A]
  NormalCell {1, }
Outputs:
  DPointCell {1, } [A]
  ChangeCell 
```

**约定**
- inputs 中必须存在至少一个使用了 `转账 lock` 或 `回收 lock` 的 cell ；
- inputs 和 outputs 中的所有 DPointCells 必须来自同一 `用户 lock` ；
- inputs 中的 DPoint 总额必须大于 outputs 中的 DPoint 总额；
- outputs 中的 DPointCells 允许大于等于 inputs 中的 DPointCells 数量，即可以在此交易对找零的 DPointCells 进行拆分；
- 此交易的手续费必须由其他 cell 进行支付；
- 
## 跨链相关交易

### 将账户跨链到其他链(LockAccountForCrossChain)

当账户需要跨到其他的链时，就可以通过此交易修改自己的状态，将自己锁定，后续将由跨链节点在其他链铸造出相应的 NFT 。

**action 结构**

```
table ActionData {
  action: "lock_account_for_cross_chain",
  params: [coin_type, chain_id, role],
}
```

- coin_type，8 bytes，小端编码的 u64
- chain_id，8 bytes，小端编码的 u64
- role，1 byte，此交易要求 owner 进行签名，所以是常量 `0x00`

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  eip712-lib
  TimeCell
  ConfigCellAccount
Inputs:
  AccountCell
Outputs:
  AccountCell
```

**约定**

- AccountCell 必须未处于**宽限期**之前 90 天；
- 输入中 AccountCell 必须处于 **Normal** 状态，即 `0x00`；
- 输出中 AccountCell 必须处于 **LockedForCrossChain** 状态，即 `0x03`；
- 输出中 AccountCell 的 `lock.args` 必须设为黑洞地址 `0x030000000000000000000000000000000000000000030000000000000000000000000000000000000000`；
- 输出中 AccountCell 的解析记录必须清空；

> 这是因为账户在跨链后如果发生了所有权的转移对应在 CKB 上也应该发生转移，为了安全起见在跨年后账户状态将以 ETH 链的状态为准，因此需要将其在 CKB 链的状态进行清空。

### 将账户从其他链跨链回来(UnlockAccountForCrossChain)

当账户需要从其他链跨回来时，如果跨链节点检测到账户在其他链已销毁，就可以通过多签在 ckb 链解锁该账户。

**action 结构**

```
table ActionData {
  action: "unlock_account_for_cross_chain",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
Inputs:
  AccountCell
Outputs:
  AccountCell
```

**约定**

- 输入中 AccountCell 必须处于 **LockedForCrossChain** 状态，即 `0x03`；
- 输出中 AccountCell 必须处于 **Normal** 状态，即 `0x00`；

### 将子账户跨链到其他链(LockSubAccountForCrossChain)

和主账户跨链交易相同，只是交易结构上不同。

**action 结构**

```
table ActionData {
  action: "lock_sub_account_for_cross_chain",
  params: [coin_type, chain_id],
}
```

**交易结构**

```
CellDeps:
  das-lock
  sub-account-cell-type
  TimeCell
  ConfigCellSubAccount
  AccountCell
Inputs:
  SubAccountCell
Outputs:
  SubAccountCell
```

**约定**

- 子账户必须未处于**宽限期**之前 90 天；
- 输入中子账户必须处于 **Normal** 状态，即 `0x00`；
- 输出中子账户必须处于 **LockedForCrossChain** 状态，即 `0x03`；
- 输出中子账户的 `lock.args` 必须设为黑洞地址 `0x030000000000000000000000000000000000000000030000000000000000000000000000000000000000`；
- 输出中子账户的解析记录必须清空；

### 将账户从其他链跨链回来(UnlockSubAccountForCrossChain)

和主账户跨链交易相同，只是交易结构上不同。

**action 结构**

```
table ActionData {
  action: "unlock_sub_account_for_cross_chain",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  sub-account-cell-type
Inputs:
  SubAccountCell
Outputs:
  SubAccountCell
```

**约定**

- 输入中子账户必须处于 **LockedForCrossChain** 状态，即 `0x03`；
- 输出中子账户必须处于 **Normal** 状态，即 `0x00`；

## 特殊交易

#### 合约脚本部署(Deploy)

Keeper 需要根据监听此交易以便及时更新各个合约脚本的 OutPoint，如此才能够在构造交易时正确的构造 CellDeps 字段。

> ⚠️ 因为是部署合约脚本的交易，所以这笔交易的发生不会受到合约脚本的约束！想要避免伪造的合约更新交易，**一定要检查下面两项：**
> - Inputs 中是否存在 DAS 官方的多签 lock script；
> - ScriptCell 的 type 字段计算 hash 后是否和公布的 Type ID 一致；

**action 结构**

```
table ActionData {
  action: "deploy",
  params: [],
}
```

**交易结构**

```
CellDeps:
Inputs:
  [ScriptCell] // 如果输入中已经有 ScriptCell 就表示更新，没有就表示创建
  [FeeCell]
Outputs:
  ScriptCell
  [ChangeCell]
```

#### 初始化 AccountCell 链表

此交易仅在 **2021-07-22T12:00:00Z** 之前可以执行，它是 DAS 链上账户链表初始化所需的交易。主要目的是用于创建 RootAccountCell ，一个有特殊意义的 AccountCell ，它的 `data.account_id` 是 `0x0000000000000000000000000000000000000000`，它的 `data.next` 是 `0xffffffffffffffffffffffffffffffffffffffff`。

在其他 AccountCell 存放 `data.account` 信息的位置，它存放了三个默克尔根，分别保存了 DAS 的致谢名单、开发团队以及其他一些留言类信息。

**action 结构**

```
table ActionData {
  action: "init_account_chain",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  [FeeCell]
Outputs:
  RootAccountCell
  [ChangeCell]
```

#### 更新 DAS 配置(Config)

此交易主要是为了创建或修改所有名为 ConfigCellXxxx 的 Cell 而设计，通过这笔交易修改的都是 DAS 运行状态的全局配置，任何链下服务也应该监听此交易以及时了解 DAS 运行状态的改变。

**action 结构**

```
table ActionData {
  action: "config",
  params: [],
}
```

**交易结构**

```
CellDeps:
  config-cell-type
Inputs:
  [ConfigCell]
  FeeCell
Outputs:
  ConfigCell
  [ChangeCell]
```

