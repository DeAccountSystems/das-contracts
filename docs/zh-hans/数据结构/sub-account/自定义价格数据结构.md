# 自定义价格配置结构


## 价格列表

> 如果没有任何一条价格规则匹配成功，那么账户将被当作不可注册账户处理。

一个子账户对应一个配置结构，一个配置结构中就可以同时存放多条价格配置，按照遍历数组的顺序执行，第一个匹配成功的价格规则就会作为当前账户的定价。
单条价格配置的字段如下：

- name ，utf-8 字符串类型，当前价格配置的名称，不能为空
- note ，utf-8 字符串类型，当前价格规则的说明信息，可以为空
- price ，整型，当前价格规则匹配成功后的账户价格，单位为 USD，与合约中其他地方相同，1 USD 存储为 `1_000_000`
- ast ，当前价格执行匹配时的抽象语法树，详见下文的抽象语法树一节

### JSON 存储结构

```json
[
    {
        "name": "...",
        "note": "...",
        "price": 0,
        "ast": { ... }
    }
]
```


## 抽象语法树

### expression

在本语法树的设计中，一切皆为 expression ，而 expression 又分为以下三类：

- operator ，此类 expression 会先对其参数进行计算得到下面的 **value** ，然后根据预定义的逻辑运算规则进行计算，并返回 `true` 或 `false`；
- function ，此类 expression 会先对其参数进行计算得到下面的 **value** ，然后根据自定义的函数逻辑进行计算，并返回 `true` 或 `false`；
- variable ，此类 expression 代表内置变量，如账户名、账户长度等信息；
- value ，此类 expression 代表 `int, binary, string` 等类型，必须结合 **operator** 或者 **funtion** 使用；

### operator

预定义的 operator 有以下几种 `symbol`：

- `and` ，表示 expression 之间为且关系，这种 operator 能接受多个 expression；
- `or` ，表示 expression 之间为或关系，这种 operator 能接受多个 expression；
- `not` ，表示对 expression 取非关系，这种 operator 只能接受 1 个 expression；
- `>` ，表示对两个 expression 进行大于对比，这种 operator 只能接受 2 个 expression ，第一个 expression 在左，第二个 expression 在右进行对比；
- `>=` ，表示对两个 expression 进行大于等于对比，这种 operator 只能接受 2 个 expression ，第一个 expression 在左，第二个 expression 在右进行对比；
- `< ` ，表示对两个 expression 进行小于对比，这种 operator 只能接受 2 个 expression ，第一个 expression 在左，第二个 expression 在右进行对比；
- `<=` ，表示对两个 expression 进行小于等于对比，这种 operator 只能接受 2 个 expression ，第一个 expression 在左，第二个 expression 在右进行对比；
- `==` ，表示对两个 expression 进行等于对比，这种 operator 只能接受 2 个 expression ，第一个 expression 在左，第二个 expression 在右进行对比；

### function

预定义的 function 有以下几种：

#### include_chars

检查账户名中是否包含特定字符，如果包含则返回 true ，反之返回 false ：

```
fn include_chars(account: account_chars, chars: string[]) -> bool;
```

#### include_charset

检查账户名中的字符是否包含特定字符集，如果包含则返回 true ，反之返回 false ：

```
fn include_charset(account: account_chars, charset: charset_type) -> bool;
```

#### in_whitelist

检查账户名是否存在于白名单中，如果是则返回 true ，反之返回 false ：

```
fn in_whitelist(account: string, root: binary, proof: binary) -> boolu
```

### variable

预定义的内置变量有以下几种：

- account ，代表账户名的 utf-8 字符串，不含后缀部分，比如 `xxxxx.bit` 的 account 变量就是 `xxxxx`，再比如 `xxxxx.yyy.bit` 的 account 变量就是 `xxxxx`；
- account_chars ，代表账户名的 AccountChars 数据结构，其包含了账户名中每一个字符的所有信息；
- account_length ，代表账户名的字符长度，**也就是 AccountChars 数据结构长度**；

### value

预定义的 value 类型有以下几种：

- uint8
- uint32
- uint64
- binary ，对应其他语言中的 `Buffer`、`Byte` 等类型，其在 json 中的存储方式为含 `0x` 前缀的 hex 字符串
- string ，utf-8 编码的字符串类型
- string[] ，utf-8 编码的字符串数组类型
- charset_type ，以 utf-8 字符串存放的字符集类型枚举值，可用值有：
    - Emoji
    - Digit
    - En
    - ZhHans
    - ZhHant
    - Ja
    - Ko
    - Ru
    - Tr
    - Th
    - Vi


### JSON 存储结构

```json
{
    "type": "operator",
    "symbol": {symbol},
    "expressions": [
        {expression},
        {expression},
        ...
    ]
}

{
    "type": "function",
    "name": {string},
    "arguments": [
        {expression},
        {expression},
        {expression},
        ...
    ]
}

{
    "type": "variable",
    "name": "account" // account|account_chars|account_length
}

{
    "type": "value",
    "value_type": "uint", // unit|int|binary|string|charset_type
    "value": {value}
}
```

## 实际结构示例

### 按照长度定价

```json
[
    {
        "name": "1 位账户",
        "note": "",
        "price": 100000000, // 100 USD
        "ast": {
            "type": "operator",
            "symbol": "==",
            "expressions": [,
                {
                    "type": "variable",
                    "name": "account_length"
                },
                {
                    "type": "value",
                    "value_type": "uint",
                    "value": 1
                }
            ]
        }
    },
    {
        "name": "2 位账户",
        "note": "",
        "price": 10000000, // 10 USD
        "ast": {
            "type": "operator",
            "symbol": "==",
            "expressions": [,
                {
                    "type": "variable",
                    "name": "account_length"
                },
                {
                    "type": "value",
                    "value_type": "uint",
                    "value": 2
                }
            ]
        }
    }
    ...
    {
        "name": "8 位及以上账户",
        "note": "",
        "price": 100000, // 0.1 USD
        "ast": {
            "type": "operator",
            "symbol": ">=",
            "expressions": [,
                {
                    "type": "variable",
                    "name": "account_length"
                },
                {
                    "type": "value",
                    "value_type": "uint",
                    "value": 8
                }
            ]
        }
    }
]
```

### 按照长度及字符集定价

```json
[
    {
        "name": "1 位数字账户",
        "note": "",
        "price": 100000000, // 100 USD
        "ast": {
            "type": "operator",
            "symbol": "and",
            "expressions": [,
                {
                    "type": "operator",
                    "symbol": "==",
                    "expressions": [,
                        {
                            "type": "variable",
                            "name": "account_length"
                        },
                        {
                            "type": "value",
                            "value_type": "uint",
                            "value": 1
                        }
                    ]
                },
                {
                    "type": "function",
                    "name": "include_charset",
                    "expressions": [,
                        {
                            "type": "variable",
                            "name": "account_charts"
                        },
                        {
                            "type": "value",
                            "value_type": "charset_type",
                            "value": "Digit"
                        }
                    ]
                }
            ]
        }
    },
]
```

### 按照是否含有特定字符定价

```json
[
    {
        "name": "特殊字符账户",
        "note": "",
        "price": 100000000, // 100 USD
        "ast": {
            "type": "function",
            "name": "include_chars",
            "expressions": [,
                {
                    "type": "variable",
                    "name": "account_charts"
                },
                {
                    "type": "value",
                    "value_type": "string[]",
                    "value": [
                        "⚠️",
                        "❌",
                        "✅"
                    ]
                }
            ]
        }
    },
]
```

### 按照白名单定价

```json
[
    {
        "name": "特殊账户",
        "note": "",
        "price": 10000000, // 10 USD
        "ast": {
            "type": "function",
            "name": "in_whitelist",
            "expressions": [,
                {
                    "type": "variable",
                    "name": "account"
                },
                {
                    "type": "value",
                    "value_type": "binary",
                    "value": "0x..."
                },
                {
                    "type": "value",
                    "value_type": "binary",
                    "value": "0x..."
                },
            ]
        }
    },
]
```


## molecule 编码

```
table SubAccountPriceRule {
    name: Bytes,
    note: Bytes,
    price: Uint64,
    ast: PriceRuleExpression,
}

vector SubAccountPriceRules <SubAccountPriceRule>;

// Because the molecule do not support recursive type, we can not use union here.
table PriceRuleExpression {
    // Indicate the real type of expression field:
    // - 0x00 PriceRuleOperator
    // - 0x01 PriceRuleFunction
    // - 0x02 PriceRuleVariable
    // - 0x03 PriceRuleValue
    expression_type: byte,
    expression: Bytes,
}

vector PriceRuleExpressions <PriceRuleExpression>;

table PriceRuleOperator {
    // Indicate the operator type:
    // - 0x00 `not`
    // - 0x01 `and`
    // - 0x02 `or`
    // - 0x03 `>`
    // - 0x04 `>=`
    // - 0x05 `<
    // - 0x06 `<=`
    // - 0x07 `==`
    symbol: byte,
    expressions: PriceRuleExpressions,
}

table PriceRuleFunction {
    // Indicate the function name:
    // - 0x00 `include_chars`
    // - 0x01 `include_charset`
    // - 0x02 `in_whitelist`
    name: byte,
    arguments: PriceRuleExpressions,
}

table PriceRuleVariable {
    // Indicate the variable name:
    // - 0x00 `account`
    // - 0x01 `account_chars`
    // - 0x02 `account_length`
    name: byte,
}

table PriceRuleValue {
    // Indicate the value type
    // - 0x00 uint8
    // - 0x01 uint32
    // - 0x02 uint64
    // - 0x03 binary
    // - 0x04 string
    // - 0x05 string[]
    // - 0x06 charset_type
    value_type: byte,
    value: Bytes,
}
```
