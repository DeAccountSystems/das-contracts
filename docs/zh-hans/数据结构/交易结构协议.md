#  标准交易结构

因为 CKB 上的合约脚本不存在接口一说，所以这里我们定义了一系列的交易结构代替对接口的定义，所以可以从理解接口的角度来理解下面所列举的交易结构。这些结构要求最终实现链上交易时必须保证以下几点：

- `CellDeps`, `Inputs` 和 `Outpus` 中的 Cell 类型和数量必须正确；
- 在有明确要求的交易中 Cell 的顺序也必须正确；
- `ActionData` 必须在 `transaction.witnesses` 中明确提供；

> 关于各类型 Cell 的具体技术要求，详见 [Cell 结构协议](./Cell-结构协议.md) 。

> CKB 官方的 signall 和 multisigh lock script 所需的 CellDeps 不会在下面交易中列出，但是你仍然应该将其添加到交易的 CellDeps 中。

> 所有的交易手续费都是由交易的发起方进行支付。


## 文档术语与约定

> 本文档一切信息需要基于 [RFC-0022 CKB Transaction Structure](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md) 之上进行理解，如果对于 CKB 的交易结构缺乏足够的理解可能会对理解本文档造成障碍。

|    术语    |                                                   说明                                                    |
| ---------- | --------------------------------------------------------------------------------------------------------- |
| ActionData | 一段 DAS 交易必须携带的数据，详见 [数据存储方案](./数据存储方案.md)                                       |
| NormalCell | CKB 中的 Cell 都有 lock, type, outputs_data 三个必要属性，这里指的是 type 与 outputs_data 为空的一类 Cell |
| FeeCell    | 支付交易所需的各种费用的 NormalCell                                                                       |
| ChangeCell | 存放交易找零的 NormalCell                                                                                 |
| ScriptCell | 指部署了合约脚本可执行文件的 Cell                                                                         |

|        符号         |                                                                                        说明                                                                                        |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [XxxYyyCell]        | 代表 XxxYyyCell 为可选                                                                                                                                                             |
| XxxYyyCell (n)      | 代表 XxxYyyCell 是有序的，这是第 n 个 XxxYyyCell                                                                                                                                   |
| XxxYyyCell {n}      | {4} 代表 XxxYyyCell 有且仅有 4 个<br>{3,} 代表 XxxYyyCell 至少要有 3 个<br/>{,2} 代表 XxxYyyCell 最多有 2 个<br/>{1,4} 代表 XxxYyyCell 数量介于 1 ~ 4 之间                         |
| XxxYyyCell [A]      | 代表交易不同部分的多个 XxxYyyCell 需要满足一致的排序<br/>Inputs/Output/CellDeps 中同样带有 `[A]` 标记的 XxxYyyCell 需要满足一致的排序<br>其中的 A 代表 A 类有序规则，也可以是 B、C |
| ConfigCellXXXX.yyyy | 指代数据需要去某个 ConfigCell 的 witness 中的特定字段获取，详见[ConfigCell](./Cell-结构协议.md#ConfigCell)                                                                         |

> 所有的 hash 都是使用的同一种 hash 算法，即 [ckbhash 算法](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md#crypto-primitives)。


## Keeper 相关交易

### 提案类交易

#### 发起提案(Propose)

这笔交易会创建一个 ProposalCell 并验证相关 PreAccountCell 中账户名的唯一性。这个 ProposalCell 的 `witness.slices` 是一个特殊的 `SliceList` 结构，该结构是对链上账户链的多个切片的描述，因此 CellDeps 中的 AccountCell 和 PreAccountCell 必须按照这个 `SliceList` 结构进行排序，简单来说就是 AccountCell 和 PreAccountCell 必须合并在一个数组中按照 account ID 进行字节排序。

**action 结构**

```
table ActionData {
  action: "propose",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellProposal
  // 需包含 witnesses 数据中 slices 所列举的所有 AccountCell 和 PreAccountCell
  AccountCell [A] {1,}
  PreAccountCell [A] {1,}
Inputs:
  FeeCell
Outputs:
  ProposalCell
  [ChangeCell]
```

#### 扩展提案(ExtendProposal)

这里的含义是基于现有提案创建新提案，而不是将现有提案消费掉，所以现有 ProposalCell 需要放在 CellDeps 字段。这笔交易需要和创建提案交易一样对 AccountCell 和 PreAccountCell 进行排序。

**action 结构**

```
table ActionData {
  action: "extend_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellProposal
  ProposalCell (n)
  // 需包含 witnesses 数据中 slices 所列举的且不存在于 ProposalCell(n) 中的 AccountCell 和 PreAccountCell
  AccountCell [A] {1,}
  PreAccountCell [A] {1,}
Inputs:
  FeeCell
Outputs:
  ProposalCell (n + 1)
  [ChangeCell]
```

#### 确认提案(ConfirmProposal)

提案在被确认之前必须等待 n 个区块高度，n 可以从 `ConfigCellProposal.proposal_min_confirm_interval` 获取。

**action 结构**

```
table ActionData {
  action: "confirm_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  account-cell-type
  pre-account-cell-type
  income-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellMain
  ConfigCellProfitRate
Inputs:
  ProposalCell
  AccountCell [A] {1,}
  PreAccountCell [A] {1,}
  [IncomeCell] // 如果总利润不足 IncomeCell 的存储费，那么输入中可以放入一个空的 IncomeCell
  [FeeCell]
Outputs:
  AccountCell [A]
  IncomeCell {1,}
  ChangeCell // 必须有一个 ChangeCell 把 ProposalCell.capacity 退还给提案发起者
  [ChangeCell] // 其余的找零可以根据情况需要安排
```

##### AccountCell 与 PreAccountCell 排序

和创建提案交易一样这里 Inputs 中的 AccountCell 和 PreAccountCell 必须合并在一个数组中按照 account ID 进行字节排序，并且 Outputs 中的 AccountCell 也需要按照 account ID 进行字节排序。

##### 利润分配

当提案确认通过新账户就此注册成功，每个 PreAccountCell 中携带的注册费也将变成 DAS 最关键的利润来源。因此这笔交易需要按照以下规则对利润进行分配：

- 提案发起者的利润分成，比例来自 `ConfigCellProfitRate.proposal_create`；
- 提案通过者的利润分成，比例来自 `ConfigCellProfitRate.proposal_confirm`；
- 渠道商的利润分成，比例来自 `ConfigCellProfitRate.channel`；
- 邀请人的利润分成，比例来自 `ConfigCellProfitRate.inviter`；
- DAS 官方的利润分成，比例为**总利润 - 以上各个角色的利润**；

以上利润中，除了提案通过者的利润分成，其他角色的利润分成都需要放在 IncomeCell 中，避免因为利润不足 61 CKB 而无法转出的问题。因为提案通过者是负责构造交易的角色，所以它可以自己在 Inputs 中放入一些 NormalCell 来凑够 61 CKB 。

> ⚠️ 注意提案发起者的利润是记录在 IncomeCell 中的，但是 ProposalCell.capacity 是需要直接退还给提案发起者的，这样设计的目的主要是为了保证提案发起者能够较快拿回自己创建提案的成本从而避免运行 keeper 需要质押过多的 CKB。

#### 回收提案(RecycleProposal)

当提案中涉及的 PreAccountCell 因为某种原因被花费掉之后，提案就无法通过了。因此提案的发起者可以通过回收无法通过的提案回收 ProposalCell 占用的 CKB。提案在被回收之前必须等待 n 个区块高度，n 可以从 `ConfigCellProposal.proposal_min_recycle_interval` 获取。

**action 结构**

```
table ActionData {
  action: "recycle_proposal",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  proposal-cell-type
  TimeCell
  HeightCell
  ConfigCellRegister
Inputs:
  ProposalCell
  [FeeCell]
Outputs:
  ChangeCell // 必须有一个 ChangeCell 把 ProposalCell.capacity 退还给提案发起者
  [ChangeCell] // 其余的找零可以根据情况需要安排
```

### IncomeCell 相关交易

#### 创建(CreateIncome)

任何人都可以执行这笔交易创建 IncomeCell ，但是这种行为没有经济激励，所以此交易主要是 DAS 官方来根据链上情况动态的创建并保持一定数量的空 IncomeCell 。这些空 IncomeCell 无法用于合并，但是能在通过提案交易中用于接收利润，解决提案交易中的利润不足 IncomeCell 存储费的情况。

**action 结构**

```
table ActionData {
  action: "create_income",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  income-cell-type
  ConfigCellMain
  ConfigCellIncome
Inputs:
  FeeCell
Outputs:
  IncomeCell
  [ChangeCell]
```

#### 合并(ConsolidateIncome)

这笔交易主要的作用是把存放在 IncomeCell 中的利润释放出来转给利润的所有者，其必须遵循以下约束：

- 对于空的 IncomeCell ，**只有一条账目并且是创建者支付的存储费，这种 IncomeCell 不能被合并**；
- 合并的输入必须是 2 个或以上的 IncomeCell；
- 合并的输出的所有 IncomeCell 中，账目记录的总数必须比输入更少；
- 合并的输出的所有 IncomeCell 中，其中同一个 lock script 的账目记录只能有一条；
- 对于**金额满足最小转出额的 lock script** ，可从 `ConfigCellIncome.min_transfer_capacity` 获取，应当将它所拥有的金额直接转出到此 lock script，除非转出完成后输出中的 IncomeCell 缺少足够的存储费；
- 转账给 lock script 时，合并交易的发起人可以按照 `ConfigCellProfitRate.income_consolidate` 中配置项拿走部分做为手续费；
- 如果转账的 lock script 是某个 inputs 中 IncomeCell 的创建者或者 DAS 的收款 lock script，那么合并交易的发起人不可以从这笔转账中拿走手续费；
- 因为转出而导致输出中的 IncomeCell 缺少足够存储费的交易，被称为**需要填充的交易**；
- 对于**需要填充的交易**，可以拿应当转出的金额中的一部分进行填充，具体用多少填充取决于合并交易发起者；

> IncomeCell 需要的存储费可以从 `ConfigCellIncome.basic_capacity` 获取。

**Example**

假设现在配置中的存储费是 200 CKB，最小转出额是 100 CKB，现在有两个 IncomeCell ：

```
IncomeCell A:
  creator: lock-a
  lock-a: 200 CKB
  lock-b: 99 CKB
  lock-c: 99 CKB
  lock-d: 5 CKB

IncomeCell B:
  creator: lock-a
  lock-a: 200 CKB
  lock-b: 1 CKB
  lock-c: 1 CKB
  lock-e: 5 CKB
```

那么合并后的结果就可以是 ：

```
IncomeCell C:
  creator: null // 使用 Script::default() 即可
  lock-a: 190 CKB // 实际上 lock-a, lock-b, lock-c 任意一人或多人留下 190 CKB 即可
  lock-d: 5 CKB
  lock-e: 5 CKB

Cell:
	lock-a: 210 CKB
Cell:
	lock-b: 100 CKB
Cell:
	lock-c: 100 CKB
```

这里 a、b 或 c 任一人或多人留下足够维持 IncomeCell 存储费的 CKB 即可，因为 lock-d 和 lock-e 的金额太少无法转出，导致 IncomeCell 无法销毁。具体 IncomeCell 中留多留少合约不做限制，但是能够转出越多，合并交易发起人可以拿到的手续费越多，所以这里合并交易发起人根据自己的能力尽可能多拿即可。

**action 结构**

```
table ActionData {
  action: "consolidate_income",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  income-cell-type
  ConfigCellIncome
  ConfigCellProfitRate
Inputs:
  IncomeCell {2,}
  [FeeCell]
Outputs:
  IncomeCell {1,}
  [ChangeCell]
```

### 运行维护类交易

#### 回收逾期账户(RecycleExpiredAccountByKeeper)

**action 结构**

```
table ActionData {
  action: "recycle_expired_account_by_keeper",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell (n - 1)  // 逾期账户的前一个账户，需要修改 next 指针
  AccountCell (n)      // 逾期状态的账户，这个 Cell 会被销毁
  [FeeCell]
Outputs:
  AccountCell (n - 1)
  ChangeCell // AccountCell (n) 的存储费会退还给至 AccountCell (n) 的 owner lock
  [ChangeCell]
```

#### 强制还原账户(ForceRecoverAccountStatus)

当账户处于非普通状态时，即 `witness.status != 0` 时，同时账户又到达了生命周期中的**宽限期**，那么此时 Keeper 可以**强制还原账户的状态**，以便在
账户**完全到期**后进行回收。

// TODO 有待讨论

> 对于竞拍中的账户，如果已经有人出价了，那么 Keeper 就不能强制还原了。但是 AccountCell 进入**宽限期**后，竞拍者也不能再通过 AccountAuctionCell 
进行出价，竞拍时间结束后账户就成交给最后的出价者。

**action 结构**

```
table ActionData {
  action: "force_recover_account_status",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  [account-sale-cell-type]
  [account-auction-cell-type]
  balance-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
Inputs:
  AccountCell
  [AccountSaleCell] // 如果账户 status == 1，那么就必须携带对应的 AccountSaleCell
  [AccountAuctionCell] // 如果账户 status == 2，那么就必须携带对应的 AccountAuctionCell
Outputs:
  AccountCell
  ChangeCell // 发生 AccountSaleCell, AccountAuctionCell 被销毁等情况时，必须退还用户其中的 capacity
```

**约定**

- AccountCell 必须是**出售中**或**拍卖中**，即 1 或 2；
- 销毁 AccountSaleCell, AccountAuctionCell 时，这些 Cell 的 capacity 必须以 BalanceCell 的形式退还用户；
- Keeper 可以从退还的金额中拿出 10_000 shannon 作为交易手续费；


## 用户相关交易

### 注册相关交易

#### 申请注册账户(ApplyRegister)

这是整个注册流程中的第一笔交易，为了防止用户期望注册的账户名被抢注，因此这笔交易中只需提供 hash 后的账户名。
输出中的 ApplyRegisterCell 就是凭证，必须等待一定的区块高度后才能拿着它进行下一步的预注册，所需等待的区块数可以从 `ConfigCellApply.apply_min_waiting_block_number` 中获取。

**action 结构**

```
table ActionData {
  action: "apply_register",
  params: [],
}
```

**交易结构**

```
CellDeps:
  apply-register-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellApply
Inputs:
  FeeCell
Outputs:
  ApplyRegisterCell
  [ChangeCell]
```

#### 申请注册退款(RefundApply)

如果用户创建的 ApplyRegisterCell 在超过最大等待时间后还没有被 Keeper 拿去进行预注册，那么这个 ApplyRegisterCell 就可以通过这笔交易进行退款。
ApplyRegisterCell 可以回收前需要等待的区块数可以从 `ConfigCellApply.apply_max_waiting_block_number` 中获取。

> 由于 ApplyRegisterCell 可以使用任意 lock script ，因此使用用户自己的 lock script 创建的 ApplyRegisterCell 需要用户签名后才能发起此交易。

**action 结构**

```
table ActionData {
  action: "refund_apply",
  params: [],
}
```

**交易结构**

```
CellDeps:
  apply-register-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellApply
Inputs:
  ApplyRegisterCell
Outputs:
  ChangeCell
```

#### 预注册账户(PreRegister)

这是整个注册流程中的第二笔交易，用户需要在这笔交易中提供期账户的明文并支付注册费。作为输入的 ApplyRegisterCell 必须等待 n 个区块且不能等待超过 m 个区块。n 可以从 `ConfigCellApply.apply_min_waiting_block_number` 中获取，m 可以从 `ConfigCellApply.apply_max_waiting_block_number` 中获取。

另一个必须注意的是这笔交易需要包含

**action 结构**

```
table ActionData {
  action: "pre_register",
  params: [],
}
```

**交易结构**

```
CellDeps:
  always-success
  apply-register-cell-type
  pre-account-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellMain
  ConfigCellAccount
  ConfigCellApply
  ConfigCellPreservedAccountXX
  ConfigCellCharSetXxxx {1,}
Inputs:
  ApplyRegisterCell
  {FeeCell}
Outputs:
  PreAccountCell
  {ChangeCell}
```

**ConfigCellPreservedAccountXX**

ConfigCellPreservedAccountXX 存在 ConfigCellPreservedAccount00 ～ ConfigCellPreservedAccount19 总共 20 个，它们的用途是存放受保护的账户名。受限于 CKB 的 lock script 对 `transaction.witnesses` 字段的体积限制，所以进行了拆分，使用时只需选择其中正确的一个即可。选择的方法如下：

- 去掉账户名的 `.bit` 后缀，并进行 hash；
- 取 hash 的第一个字节，将它转为一个 u8 整型的数字；
- 用上面得到的数字对 20 取模；
- 根据取模得到的结果选择对应尾号的 ConfigCellPreservedAccountXX；

**ConfigCellCharSetXxxx**

ConfigCellCharSetXxxx 存在的数量并不固定，它们的作用是保存 DAS 支持的字符集，同样是受限于 `transaction.witnesses` 字段的体积限制所以做了拆分。使用时只需选择其中正确的一个即可，选择方法如下：

- 解析 PreAccountCell 的 witness ，遍历 `account` 字段；
- `account` 字段中的每一个元素为 `AccountChar` 类型，其 `char_set_name` 字段为**字符集 ID**；
- 将字符集 ID 加上 `100000` 后就可以得到 ConfigCellCharSetXxxx 对应的 **Config ID**；
- 最后就可以根据这些 Config ID 一个或多个 ConfigCellCharSetXxxx；

> 关于 **字符集 ID** 和 **Config ID** 详见 [Cell 结构协议](./Cell-结构协议.md) 。

#### 预注册退款(RefundPreRegister)

如果偶然出现链上同时存在多个同样账户名的 PreAccountCell 时，最终只能有一个通过通过提案注册成账户，剩余未注册成功的 PreAccountCell 就可以通过这笔交易回收并退还用户剩余的注册费。

**action 结构**

```
table ActionData {
  action: "refund_pre_register",
  params: [],
}
```

**交易结构**

```
CellDeps:
  ScriptCells
  TimeCell
  HeightCell
  ConfigCellMain
  AccountCell // 这里引用是为了限制了恶意发起退款
Inputs:
  PreAccountCell
Outputs:
  ChangeCell // 必须有一个 ChangeCell 把注册费退还用户，Keeper 可从中拿取最多 10000 shannon 作为交易手续费
```

### 账户管理相关交易

所有的账户管理相关交易的 `ActionData` 中多了一个 `permission` 参数，此参数表明了当前交易所需权限，并会被 account-cell-type 以及 das-lock 两个合约脚本共同检查，所以必须正确填写。`permission` 可选的值有：

- 0x00 表示此交易需要 owner 权限；
- 0x01 表明此交易需要 manager 权限；

> 账户的 owner 权限和 manager 权限是互斥的，即要求 manager 权限的操作 owner 也是无权执行的。

> 账户进入宽限期后不能执行除了[账户续期](#账户续期)以外的任何交易。

#### 账户转让(TransferAccount)

用户可以通过此交易将 AccountCell 转给他人，即永久转移账户的所有权。交易执行后会修改 AccountCell 的 `lock.args` 字段，并且要求输出中的 AccountCell 的 `lock.args` 中 owner 和 manager 必须是相同的 lock hash ，因为账户转移给他人后 manager 仍然归属原用户可能导致潜在的风险。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.transfer_account_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.transfer_account_fee` 获取。

**action 结构**

```
table ActionData {
  action: "transfer_account",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 修改管理员(EditManager)

用户通过这笔交易可以指定他人才有账户记录的修改权限。交易执行后会修改 AccountCell 的 `lock.args` 字段，并要求输出中的 AccountCell 的 `lock.args` 的 manager 的部分必须和输入中不同。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.edit_manager_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.edit_manager_fee` 中获取。

**action 结构**

```
table ActionData {
  action: "edit_manager",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellMain
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 修改记录(EditRecords)

这里修改的是账户的记录，是一个账户在日常使用中最频繁读取的信息。交易执行后会修改 AccountCell 的 `witness.records` 中存放的信息。

同一个账户执行此交易时有频率限制，每次执行此交易的时间间隔需要从 `ConfigCellAccount.edit_records_throttle` 获取。交易手续费可以从 AccountCell 中扣除，单次手续费的最大额度需要从 `ConfigCellAccount.edit_records_fee` 中获取。

> 因为前面已经提到过 owner 权限和 manager 权限是互斥的，所以**修改记录的权限仅 manager 才有**。

**action 结构**

```
table ActionData {
  action: "edit_records",
  params: [0x01],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
  ConfigCellRecordKeyNamespace
Inputs:
  AccountCell
  [FeeCell]
Outputs:
  AccountCell
  [ChangeCell]
```

#### 账户续期(RenewAccount)

每个账户对应的 AccountCell 都在 `data` 中存放了到期时间，想要延长此到期时间的唯一方法就是执行这笔交易。交易执行后会修改 AccountCell 的 `data` 中存放的到期时间为最新值，具体数值取决于字符的费用多少，但是最少不能少于一年。

> 任何人都可以为任何账户名续费，合约不会验证资金来源。

**action 结构**

```
table ActionData {
  action: "renew_account",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  income-cell-type
  TimeCell
  HeightCell
  QuoteCell
  ConfigCellMain
  ConfigCellPrice
  ConfigCellAccount
Inputs:
  AccountCell
  [IncomeCell] // 如果续费金额不足 IncomeCell 存储费，那么就可以在输入中放入一个空的 IncomeCell
  FeeCell // 用户需要通过一个 NormalCell 来支付费用
Outputs:
  AccountCell
  IncomeCell // 用于存放用户支付的费用
  [ChangeCell]
```

### 反向解析相关交易

#### 声明反向解析(DeclareReverseRecord)

该交易可以将一个账户标记为某个地址的解析记录。

> ReverseRecordCell 的创建是不受数量限制的，当发生重复创建时，会遵循[特定的去重规则](./Cell-结构协议.md#ReverseRecordCell)取唯一一个。

**action 结构**

```
table ActionData {
  action: "declare_reverse_record",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  balance-cell-type
  reverse-record-cell-type
  ConfigCellMain
  ConfigCellReverseResolution
  AccountCell
Inputs:
  BalanceCell {1,}
Outputs:
  ReverseRecordCell
  [BalanceCell]
```

**约定**

- ReverseRecordCell 的 lock 必须和 inputs[0] 的 BalanceCell 一致，如此才能保证反向解析只有拥有对应地址私钥才能声明；
- ReverseRecordCell 必须是 das-lock；
- ReverseRecordCell 中的 account 必须和 AccountCell 一致；

#### 变更反向解析(RedeclareReverseRecord)

该交易可以修改一条现存反向解析对应的账户。

**action 结构**

```
table ActionData {
  action: "redeclare_reverse_record",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  balance-cell-type
  reverse-record-cell-type
  ConfigCellMain
  ConfigCellReverseResolution
  AccountCell
Inputs:
  ReverseRecordCell
Outputs:
  ReverseRecordCell
```

**约定**

- 只能修改 ReverseRecordCell.data.account；

#### 撤销反向解析(RetractReverseRecord)

该交易可以撤销一条或多条反向解析声明。

**action 结构**

```
table ActionData {
  action: "retract_reverse_record",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  balance-cell-type
  reverse-record-cell-type
  ConfigCellMain
  ConfigCellReverseResolution
Inputs:
  ReverseRecordCell {1,}
Outputs:
  BalanceCell {1,}
```

**约定**

- outputs 中必须包含等额于 inputs 中 ReverseRecordCell 存储费的退款；

### 二级市场相关交易

#### 一口价交易

##### 开始出售(StartAccountSale)

该交易可以将可以账户标记为出售状态，交易会创建一个 AccountSaleCell ，其中存放了售价等相关信息，但是售价不得低于 `ConfigCellSecondaryMarket.min_sale_price` 。

**action 结构**

```
table ActionData {
  action: "start_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
Inputs:
  AccountCell
  BalanceCell {1,}
Outputs:
  AccountCell
  AccountSaleCell
  [BalanceCell]
```

**约定**

- AccountCell 和 AccountSaleCell 的 lock 必须一致；
- AccountSaleCell 的 capacity 需要等于 `ConfigCellSecondaryMarket.sale_cell_basic_capacity + ConfigCellSecondaryMarket.sale_cell_prepared_fee_capacity`
- AccountSaleCell 需要遵守其他 `ConfigCellSecondaryMarket.sale_*` 配置项的限制；

##### 修改商品信息(EditAccountSale)

该交易可以修改存放在 AccountSaleCell 中的售价等信息。

**action 结构**

```
table ActionData {
  action: "edit_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellSecondaryMarket
  AccountCell
Inputs:
  AccountSaleCell
Outputs:
  AccountSaleCell
```

**约定**

- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；

##### 取消出售(CancelAccountSale)

只要账户未被售出，就可以通过此交易取消账户的一口价出售。

**action 结构**

```
table ActionData {
  action: "cancel_account_sale",
  params: [0x00],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
Inputs:
  AccountCell
  AccountSaleCell
Outputs:
  AccountCell
  BalanceCell
```

**约定**

- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 交易手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- 必须存在一个包含 AccountSaleCell 退款的 ChangeCell ；

##### 购买账户(BuyAccount)

其他用户可以通过这笔交易购买出售中的账户，购买成功账户就转移到新账户名下，原有的解析记录都会被清空。

**action 结构**

```
table ActionData {
  action: "buy_account",
  params: [inviter_lock, channel_lock],
}
```

- inviter_lock ，如果购买账号的用户有邀请人，可以通过此参数传递邀请人信息，即一个 molecule 编码的 Script 结构，没有邀请人时需要传入 Script 结构的默认值； 
- channel_lock ，购买渠道可以通过此参数填入自己的收款地址来收取分成，同样必须是一个 molecule 编码的 Script 结构；

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  account-sale-cell-type
  TimeCell
  HeightCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
Inputs:
  AccountCell
  AccountSaleCell
  BalanceCell {1,}
Outputs:
  AccountCell
  IncomeCell // 存放分配给 inviter_lock 和 channel_lock 的利润
  BalanceCell // AccountSaleCell 的 capacity 必须以使用 das-lock 的 NormalCell 形式退还给账户的出售者
```

**约定**

- inviter_lock 和 channel_lock 如果为 Script 结构的默认值，就视为没有邀请人，没有渠道商；
- AccountCell 需要和 AccountSaleCell 拥有一样的 account ID ；
- 交易手续费可以从 AccountSaleCell 中扣除等额于 `ConfigCellSecondaryMarket.common_fee` 的金额；
- inviter, channel, DAS 三个角色的利润需要存放在 IncomeCell 中，seller 的利润需要存放在一个 NormalCell 中；
- 可以在这笔交易交易中直接创建 IncomeCell，IncomeCell 需要满足以下约束：
  - 记录总金额必须和 IncomeCell.capacity 相等；
  - 如果 invitor、chanenl、DAS 的 lock script 相同，那么他们的利润相关记录必须合并；
  - 其他记录不能和利润相关记录合并；

#### 账户竞拍

##### 开始竞拍（StartAccountAuction）

同时支持 Fomo 和普通竞拍：

- Fomo 竞拍 AccountAuctionCell.prev_bidder_profit_rate 不为 0；
- 普通竞拍时只需要将 AccountAuctionCell.prev_bidder_profit_rate 设为 0 即可。

> 竞拍一旦有人出价，就不能中止，必须等到时间结束后成交。

**action 结构**

```
table ActionData {
    action: "start_account_auction",
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
   das-lock
   account-cell-type
   account-auction-cell-type
   TimeCell
   ConfigCellAccount
   ConfigCellSecondaryMarket
Inputs:
    AccountCell
    [FeeCell]
Outputs:
    AccountCell
    AccountAuctionCell
    [ChangeCell]
```

##### 修改竞拍信息（EditAccountAuction）

该交易可以修改存放在 AccountAuctionCell 中的起拍价/描述等信息，分为**可随时修改**和**无人出价前可以修改**两类信息：

- **可随时修改**包括：描述；
- **无人出价前可以修改**包括：起拍价(opening_price)、每次加价的最低比例(increment_rate_each_bid)、起拍时间(started_at)、前一个竞拍者的利润率(prev_bidder_profit_rate)

**action 结构** 

```
table ActionData {
    action: "edit_account_auction",
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
    das-lock
    account-aution-cell-type
    TimeCell
    HeightCell
    ConfigCellSecondaryMarket
Inputs:
    AccountAuctionCell
    [FeeCell]
Outputs:
    AccountAuctionCell
    [ChangeCell]
```

##### 取消出售（CancelAccountAuction）

只有在无人出价的时候，才可以通过该 action 取消拍卖。

**action 结构**

```
table ActionData {
    action: "cancel_account_auction",
    params: [0x00]
}
```

**交易结构**

```
CellDeps:
    das-lock
    account-cell-type
    account-auction-cell-type
    TimeCell
    HeightCell
    ConfigCellAccount
Inputs:
    AccountCell
    AccountAuctionCell
Outputs:
    AccountCell
    [ChangeCell]
```

##### 出价（BidAccountAuction）

出价竞拍指定账户。

**action 结构**

```
table ActionData {
    action: "bid_account_auction",
    params: [inviter_lock, channel_lock]
}
```

- inviter_lock ，如果竞拍账号的用户有邀请人，可以通过此参数传递邀请人信息，即一个 molecule 编码的 Script 结构，没有邀请人时需要传入 Script 结构的默认值；
- channel_lock ，购买渠道可以通过此参数填入自己的收款地址来收取分成，同样必须是一个 molecule 编码的 Script 结构；

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  account-auction-cell-type
  TimeCell
  ConfigCellAccount
  ConfigCellSecondaryMarket
  AccountCell
Inputs:
  AccountAuctionCell
  FeeCell
  [IncomeCell] // 如果待分配给 inviter_lock 和 channel_lock 的利润不足 IncomeCell 存储费，那么可以在输入中放入一个空 IncomeCell
Outputs:
  AccountAuctionCell
  [IncomeCell] // 存放分配给 inviter_lock 和 channel_lock 的利润
  [ChangeCell] // AccountSaleCell 的 capacity 必须退还给账户的出售者 das-lock normal cell
```

##### 确认竞拍（ConfirmAccountAuction）

// TODO 或者任何人都可以成交？

竞拍到期，最新的出价人可以确认竞拍状态，获得竞拍的账号

**action 结构**

```
table ActionData {
    action: "confirm_account_auction"
    params: [0x00],
}
```

**交易结构**

```
CellDeps:
    das-lock
    account-cell-type
    account-auction-cell-type
    TimeCell
    ConfigCellAccount
    ConfigCellAuction
Inputs:
    AccountCell
    AccountAuctionCell
Outputs:
    AccountCell
    ChangeCell // 拍卖方获得竞拍所得
```


## 特殊交易

#### 合约脚本部署(Deploy)

Keeper 需要根据监听此交易以便及时更新各个合约脚本的 OutPoint，如此才能够在构造交易时正确的构造 CellDeps 字段。

> ⚠️ 因为是部署合约脚本的交易，所以这笔交易的发生不会受到合约脚本的约束！想要避免伪造的合约更新交易，**一定要检查下面两项：**
> - Inputs 中是否存在 DAS 官方的多签 lock script；
> - ScriptCell 的 type 字段计算 hash 后是否和公布的 Type ID 一致；

**action 结构**

```
table ActionData {
  action: "deploy",
  params: [],
}
```

**交易结构**

```
CellDeps:
Inputs:
  [ScriptCell] // 如果输入中已经有 ScriptCell 就表示更新，没有就表示创建
  [FeeCell]
Outputs:
  ScriptCell
  [ChangeCell]
```

#### 初始化 AccountCell 链表

此交易仅在 **2021-07-22T12:00:00Z** 之前可以执行，它是 DAS 链上账户链表初始化所需的交易。主要目的是用于创建 RootAccountCell ，一个有特殊意义的 AccountCell ，它的 `data.account_id` 是 `0x0000000000000000000000000000000000000000`，它的 `data.next` 是 `0xffffffffffffffffffffffffffffffffffffffff`。

在其他 AccountCell 存放 `data.account` 信息的位置，它存放了三个默克尔根，分别保存了 DAS 的致谢名单、开发团队以及其他一些留言类信息。

**action 结构**

```
table ActionData {
  action: "init_account_chain",
  params: [],
}
```

**交易结构**

```
CellDeps:
  das-lock
  account-cell-type
  TimeCell
  HeightCell
  ConfigCellMain
  ConfigCellAccount
Inputs:
  [FeeCell]
Outputs:
  RootAccountCell
  [ChangeCell]
```

#### 更新 DAS 配置(Config)

此交易主要是为了创建或修改所有名为 ConfigCellXxxx 的 Cell 而设计，通过这笔交易修改的都是 DAS 运行状态的全局配置，任何链下服务也应该监听此交易以及时了解 DAS 运行状态的改变。

**action 结构**

```
table ActionData {
  action: "config",
  params: [],
}
```

**交易结构**

```
CellDeps:
  config-cell-type
Inputs:
  [ConfigCell]
  FeeCell
Outputs:
  ConfigCell
  [ChangeCell]
```
