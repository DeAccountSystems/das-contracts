# 反向解析数据存储方案


## 约束条件

此方案是反向解析的第二版设计方案，满足了以下几个需求：


## SMT 结构

[SMT](https://github.com/nervosnetwork/sparse-merkle-tree)全称 Sparse Merkle Tree ，由于当前基于 SMT 的链上存储方案已经得到了进一步验证，本且可以满足以上约束条件，因此就采用了基于 SMT 的存储方案。

该 SMT 的 leaf 的 key 和 value 进行统一的约定：

**key** ，必须是各链生成地址所用 playload 的 blake2b hash ，考虑到 32 bytes 的空间大小，此处不对公钥的来源、算法进行区分，即无论是 ECC 还是 RSA 或者其他未知的算法的公钥都可以使用，唯一必须满足的要求就是 das-lock 支持了相应的验签算法；

> **payload 必须满足的要求**
>
> 考虑未来一些不同的链可能有完全不同的地址生成、验签方式，因此这里需要对 payload 的定义进行了进一步的明确。对于目前已知的链来说，其地址的生成过程基本为： 对 public key 进行 hash -> 截取部分 hash 结果 -> 将这部分 hash 编码为字符串。因为验签过程中可以通过签名和原文推导出 public key ，因此验签时可以还原出 public key 的 hash 从而和地址中的 hash 进行对比就可以实现验签。
>
> 由此可知此处 payload 必须满足两个限制条件：
>
> 1. 是生成地址时必须使用的数据；
> 2. 是可以用于验签的数据；

**value** ，同样必须是一个 blake2b hash，其内容组成如下：
  - 0..4 bytes，是小端编码的 nonce 值，该值主要用于防止签名被重复使用，同一个公钥每进行一次操作其值就必须 +1；
  - 4.. bytes，是 utf-8 编码的 account；

## witness 存储结构

用户每次创建、编辑、删除反向解析记录操作，都对应了一条 witness 记录，其基本结构和 DAS 的其他 witness 结构相同：

```
[
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  ...
  [das, type, raw/entity/table],
  [das, type, raw/entity/table],
  [das, type, reverse_record],
  [das, type, reverse_record],
  ...
]
```

其中 [3:7] 4 个 bytes 为小端编码的 u32 整型，它标明了第 8 bytes 之后的数据类型是子账户类型，具体值详见 [Witness 类型值 DataType](./%E7%B3%BB%E7%BB%9F%E6%9E%9A%E4%B8%BE%E5%80%BC.md)。

最后一段数据 `reverse_record` 是存放用户的反向解析操作记录的 `ReverseRecord` 类型数据，其中具体的数据结构采用了和 [sub-account/witness 数据结构](./sub-account/Witness%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md) 一样的**基于 LV 编码(Length-Value)的二进制**形式。

### ReverseRecord 数据结构

对反向解析记录的操作因为实际上就是对 SMT 的操作，因此其本质上都是对 SMT leaf 的更新操作。所以一条表达对 SMT 操作记录的 witness 数据结构如下：

```
[ length ][ version ]
[ length ][ action ]
[ length ][ signature ]
[ length ][ sign_type ]
[ length ][ address_payload ]
[ length ][ proof ]
[ length ][ prev_nonce ]
[ length ][ prev_account ]
[ length ][ next_root ]
[ length ][ next_account ]
```

- `version` 小端编码的 u32 整形，指明之后字段的数据结构版本号，后续的字段有任何改变时，此字段就会 `+1`；
- `action` 当前 witness 的意图，由于 SMT 结构在上链时必然存在严重的 Cell 抢占问题，因此在同一笔交易中支持了所有的反向解析操作类型：
  - `action == update`，表明此条记录是对反向解析的更新操作，包括创建、编辑；
  - `action == remove`，表明此条记录是对反向解析的删除操作；
- `signature` 为验证用户对 key 所含公钥所有权的签名字段，其包含了对 `next_nonce, next_account` 信息的签名；
- `sign_type` 1 byte 的标识符，表明验签应该采用 das-lock 的哪一种算法：
- `address_payload` 此记录更新的公钥对应的 payload 信息，此字段进行 blake2b hash 后就应当是当前 SMT 的 leaf 的 key；
- `proof` 是验证 `prev_nonce, prev_account` 以及 `prev_nonce + 1, next_account` 存在的证明；
- `prev_nonce` 小端编码的 u32 整形，也就是当前的 nonce 值；
- `prev_account` 也就是当前的 account 值；
- `next_root` 当新的 nonce 和 account 写入 SMT 后的新的 SMT root 值；
- `next_account` 是将要更新的新 account 值；

> `prev_root`: 由于第一个 prev_root 可以从 ReverseRecordRootCell 的 outputs_data 获取，之后的 `prev_root` 就是前一条操作记录的 `next_root` 因此该字段被省略了；
> `next_nonce`: 由于 `next_nonce = prev_nonce + 1` 所以该字段被省略了；

#### 创建与删除

当一个公钥创建反向解析时，此时因为原本的 leaf 为空，因此 `prev_nonce` 和 `prev_account` 也必须为空，并且 `next_nonce` 必须为 1 。

当一个公钥删除反向解析时，因为 `nonce` 重置会有安全问题 TODO，因此 `next_nonce` 和 `next_account` 也必须为空。

#### 签名与验签

`signature` 最终会使用基于 `das-lock` 验签，因此签名的生成和验签就是 CKB、ETH、BTC 链的标准协议。唯一不同的是 `digest` 的生成，其组成为按顺序拼接以下字段，最后对其进行一次 encode/decode 转换为 Hex 类型：

- `from did: ` 字符串；
- 一个以 `ckb-default-hash` 为参数的 32 字节 blake2b hash ，创建方法是按顺序拼接以下字段后进行 hash：
  - `prev_nonce + 1`
  - `next_account`
