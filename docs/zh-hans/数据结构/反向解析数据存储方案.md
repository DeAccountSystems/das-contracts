# 反向解析数据存储方案


## 约束条件

此方案是反向解析的第二版设计方案，满足了以下几个需求：


## SMT 结构

[SMT](https://github.com/nervosnetwork/sparse-merkle-tree)全称 Sparse Merkle Tree ，由于当前基于 SMT 的链上存储方案已经得到了进一步验证，本且可以满足以上约束条件，因此就采用了基于 SMT 的存储方案。

该 SMT 的 leaf 的 key 和 value 进行统一的约定：

- key ，必须是公钥的 blake2b hash ，考虑到 32 bytes 的空间大小，此处不对公钥的来源、算法进行区分，即无论是 ECC 还是 RSA 或者其他未知的算法的公钥都可以使用，唯一必须满足的要求就是 das-lock 支持了相应的验签算法；
- value ，同样必须是一个 blake2b hash，其内容组成如下：
  - 0..4 bytes，是小端编码的 nonce 值，该值主要用于防止签名被重复使用，同一个公钥每进行一次操作其值就必须 +1；
  - 4.. bytes，是 utf-8 编码的 account；

## witness 存储结构

用户每次创建、编辑、删除反向解析记录操作，都对应了一条 witness 记录，其基本结构和 DAS 的其他 witness 结构相同：

```
[
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  ...
  [das, type, raw/entity/table],
  [das, type, raw/entity/table],
  [das, type, reverse_record],
  [das, type, reverse_record],
  ...
]
```

其中 [3:7] 4 个 bytes 为小端编码的 u32 整型，它标明了第 8 bytes 之后的数据类型是子账户类型，具体值详见 [Cell 结构协议.md/Type 常量列表/SubAccount](Cell-结构协议.md)。

最后一段数据 `reverse_record` 是存放用户的反向解析操作记录的 `ReverseRecord` 类型数据，其中具体的数据结构采用了和 [子账户数据存储方案/witness 存储结构](./子账户数据存储方案.md) 一样的**基于 LV 编码(Length-Value)的二进制**形式。

### ReverseRecord 数据结构

对反向解析记录的操作因为实际上就是对 SMT 的操作，因此其本质上都是对 SMT leaf 的更新操作。所以一条表达对 SMT 操作记录的 witness 数据结构如下：

```
[ length ][ version ]
[ length ][ action ]
[ length ][ signature ]
[ length ][ sign_expired_at ]
[ length ][ prev_proof ]
[ length ][ prev_nonce ]
[ length ][ prev_account ]
[ length ][ next_root ]
[ length ][ next_proof ]
[ length ][ next_account ]
```

- `version` 指明之后字段的数据结构版本号，类型为小端编码的 u32 整形，后续的字段有任何改变时，此字段就会 `+1`；
- `action` 当前 witness 的意图，由于 SMT 结构在上链时必然存在严重的 Cell 抢占问题，因此在同一笔交易中支持了所有的反向解析操作类型：
  - `action == update`，表明此条记录是对反向解析的更新操作，包括创建、编辑；
  - `action == remove`，表明此条记录是对反向解析的删除操作；
- `signature` 为验证用户对 key 所含公钥所有权的签名字段，其包含了对 `next_nonce, next_account` 信息的签名；
- `sign_expired_at` 指明 `signature` 签名的到期时间，**这个过期时间必须小于等于当前 ReverseRecordRootCell 的区块头中 timestamp + 30 天的时间**；
- `prev_proof` 是验证 `prev_nonce, prev_account` 存在的证明；
- `prev_nonce` 也就是当前的 nonce 值；
- `prev_account` 也就是当前的 account 值；
- `next_root` 当新的 nonce 和 account 写入 SMT 后的新的 SMT root 值；
- `next_proot` 是验证 `prev_nonce + 1, next_account` 存在的证明；
- `next_account` 是将要更新的新 account 值；

> `prev_root`: 由于第一个 prev_root 可以从 ReverseRecordRootCell 的 outputs_data 获取，之后的 `prev_root` 就是前一条操作记录的 `next_root` 因此该字段被省略了；
> `next_nonce`: 由于 `next_nonce = prev_nonce + 1` 所以该字段被省略了；

#### 创建与删除

当一个公钥创建反向解析时，此时因为原本的 leaf 为空，因此 `prev_nonce` 和 `prev_account` 也必须为空，并且 `next_nonce` 必须为 1 。

当一个公钥删除反向解析时，删除后的 leaf 应当为空，因此 `next_nonce` 和 `next_account` 也必须为空。

#### 签名与验签

`signature` 最终会使用基于 `das-lock` 验签，因此签名的生成和验签就是 CKB、ETH、BTC 链的标准协议。唯一不同的是 `digest` 的生成，其组成为按顺序拼接以下字段：

- `from did: ` 字符串的二进制字节；
- 一个以 `ckb-default-hash` 为参数的 32 字节 blake2b hash ，创建方法是按顺序拼接以下字段后进行 hash：
  - `prev_nonce + 1`
  - `next_account`
