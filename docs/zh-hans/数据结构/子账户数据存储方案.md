# 子账户数据存储方案

[TOC]

## 约束条件

在设计子账户时，我们预先定义了几个约束条件需要满足：

- 创建子账户时必须避免产生链上的存储费；
- 必须支持链上验证；

由此可以得出的，并且目前已得到大量实践验证的方案就是基于 Merkle Tree 进行链下的数据存储，通过 Merkle Proof 进行链上验证。


## witness 存储结构

当交易中涉及子账户的新增、修改、删除操作时，每个子账户需要有一条对应自己的 witness 记录，其基本结构和 DAS 的其他 witness 结构相同：

```
[
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  lock 脚本需要的签名,
  ...
  [das, type, raw/entity/table],
  [das, type, raw/entity/table],
  [das, type, sub_account],
  [das, type, sub_account],
  ...
]
```

其中 [3:7] 4 个 bytes 为大端编码的 u32 整型，它标明了第 8 bytes 之后的数据类型是子账户类型，具体值详见[Cell 结构协议.md/Type 常量列表/SubAccount](#Cell 结构协议.md)；
最后的一段 `sub_account` ，由于数据量较大，且在之前的实践中我们发现 molecule 编码在处理较长数据时在合约中性能不佳的问题存在，所以采用了以下基于 LV 编码的二进制：

```
[ length ][ signature ][ length ][ prev_root ][ length ][ current_root ][ length ][ proof ][ length ][ sub_account ][ length ][ key ][ length ][ value ]
```

其中所有的 `length` 固定为 4 Bytes 的大端编码的 u32 整型，其值为后面一段数据的长度。比如 `signature` 段数据长度为 65 Bytes，那么到 `signature` 
为止的二进制数据就是以下形式：

```
0x00000041FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...

上面的数据可以视为两个部分：
0x00000041 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...

0x00000041 就是 length 部分
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF... 就是 signature 部分
```

当某一个段数据的值为空时，其 `length` 需要为 `0x00000000`。比如 `key` 和 `value` 段数据为空时，那么这段二进制数据就是以下形式：

```
0x...FFF0000000000000000

上面的数据可以视为三个部分
0x...FFF 0x00000000 0x00000000

0x...FFF 就是 key 的 length 之前的数据
0x00000000 第一个 0x00000000 是 key 的 length ，其指明了 key 的值为空
0x00000000 第二个 0x00000000 是 value 的 length ，其指明了 value 的值为空
```

对于 `sub_account` 则是一个子账户的 molecule 编码的数据结构(**最新结构请以 [das-types](https://github.com/DeAccountSystems/das-types) 中定义为准**)：

```
table SubAccountData {
    // The lock of owner and manager
    lock: Script,
    // The first 160 bits of the hash of account.
    id: AccountId,
    // Separate chars of account.
    account: AccountChars,
    // The suffix of this sub-account, it is always .bit currently.
    suffix: Bytes,
    // The sub-account register timestamp.
    registered_at: Uint64,
    // The sub-account expiration timestamp.
    expired_at: Uint64,
    // The status of the account, 0x00 means normal, 0x01 means being sold, 0x02 means being auctioned.
    status: Uint8,
    // Resolving records of this sub-account.
    records: Records,
    // This is a count field, it mainly used to prevent replay attacks.
    nonce: Uint32,
}
```

