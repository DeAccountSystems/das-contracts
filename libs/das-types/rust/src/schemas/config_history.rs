// Generated by Molecule 0.7.3

use molecule::prelude::*;

use super::basic::*;
use super::cell::*;
#[derive(Clone)]
pub struct ConfigCellMainV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            221, 1, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 17, 1, 0, 0, 0, 0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0,
            128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0,
            60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV1::new_unchecked(v.into())
    }
}
impl ConfigCellMainV1 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV1::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV1Reader<'r> {
        ConfigCellMainV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV1 {
    type Builder = ConfigCellMainV1Builder;
    const NAME: &'static str = "ConfigCellMainV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV1Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV1Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV1Reader<'r> {
    type Entity = ConfigCellMainV1;
    const NAME: &'static str = "ConfigCellMainV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV1Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableV1Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV1Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV1,
    pub(crate) das_lock_out_point_table: DasLockOutPointTableV1,
}
impl ConfigCellMainV1Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV1) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTableV1) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV1Builder {
    type Entity = ConfigCellMainV1;
    const NAME: &'static str = "ConfigCellMainV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "bidding_cell", self.bidding_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "on_sale_cell", self.on_sale_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV1::new_unchecked(v.into())
    }
}
impl TypeIdTableV1 {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn bidding_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn on_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV1Reader<'r> {
        TypeIdTableV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV1 {
    type Builder = TypeIdTableV1Builder;
    const NAME: &'static str = "TypeIdTableV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .bidding_cell(self.bidding_cell())
            .income_cell(self.income_cell())
            .on_sale_cell(self.on_sale_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "bidding_cell", self.bidding_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "on_sale_cell", self.on_sale_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV1Reader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn bidding_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn on_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV1Reader<'r> {
    type Entity = TypeIdTableV1;
    const NAME: &'static str = "TypeIdTableV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV1Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) bidding_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) on_sale_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
}
impl TypeIdTableV1Builder {
    pub const FIELD_COUNT: usize = 7;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn bidding_cell(mut self, v: Hash) -> Self {
        self.bidding_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn on_sale_cell(mut self, v: Hash) -> Self {
        self.on_sale_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV1Builder {
    type Entity = TypeIdTableV1;
    const NAME: &'static str = "TypeIdTableV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.bidding_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.on_sale_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.bidding_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.on_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.bidding_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.on_sale_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct DasLockOutPointTableV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DasLockOutPointTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DasLockOutPointTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DasLockOutPointTableV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ckb_signall", self.ckb_signall())?;
        write!(f, ", {}: {}", "ckb_multisign", self.ckb_multisign())?;
        write!(f, ", {}: {}", "ckb_anyone_can_pay", self.ckb_anyone_can_pay())?;
        write!(f, ", {}: {}", "eth", self.eth())?;
        write!(f, ", {}: {}", "tron", self.tron())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for DasLockOutPointTableV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        DasLockOutPointTableV1::new_unchecked(v.into())
    }
}
impl DasLockOutPointTableV1 {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn ckb_signall(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn ckb_multisign(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn ckb_anyone_can_pay(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn eth(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn tron(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            OutPoint::new_unchecked(self.0.slice(start..end))
        } else {
            OutPoint::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DasLockOutPointTableV1Reader<'r> {
        DasLockOutPointTableV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DasLockOutPointTableV1 {
    type Builder = DasLockOutPointTableV1Builder;
    const NAME: &'static str = "DasLockOutPointTableV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DasLockOutPointTableV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DasLockOutPointTableV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DasLockOutPointTableV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .ckb_signall(self.ckb_signall())
            .ckb_multisign(self.ckb_multisign())
            .ckb_anyone_can_pay(self.ckb_anyone_can_pay())
            .eth(self.eth())
            .tron(self.tron())
    }
}
#[derive(Clone, Copy)]
pub struct DasLockOutPointTableV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DasLockOutPointTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DasLockOutPointTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DasLockOutPointTableV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ckb_signall", self.ckb_signall())?;
        write!(f, ", {}: {}", "ckb_multisign", self.ckb_multisign())?;
        write!(f, ", {}: {}", "ckb_anyone_can_pay", self.ckb_anyone_can_pay())?;
        write!(f, ", {}: {}", "eth", self.eth())?;
        write!(f, ", {}: {}", "tron", self.tron())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> DasLockOutPointTableV1Reader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn ckb_signall(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ckb_multisign(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ckb_anyone_can_pay(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn eth(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tron(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            OutPointReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            OutPointReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DasLockOutPointTableV1Reader<'r> {
    type Entity = DasLockOutPointTableV1;
    const NAME: &'static str = "DasLockOutPointTableV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DasLockOutPointTableV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        OutPointReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        OutPointReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        OutPointReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        OutPointReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        OutPointReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct DasLockOutPointTableV1Builder {
    pub(crate) ckb_signall: OutPoint,
    pub(crate) ckb_multisign: OutPoint,
    pub(crate) ckb_anyone_can_pay: OutPoint,
    pub(crate) eth: OutPoint,
    pub(crate) tron: OutPoint,
}
impl DasLockOutPointTableV1Builder {
    pub const FIELD_COUNT: usize = 5;
    pub fn ckb_signall(mut self, v: OutPoint) -> Self {
        self.ckb_signall = v;
        self
    }
    pub fn ckb_multisign(mut self, v: OutPoint) -> Self {
        self.ckb_multisign = v;
        self
    }
    pub fn ckb_anyone_can_pay(mut self, v: OutPoint) -> Self {
        self.ckb_anyone_can_pay = v;
        self
    }
    pub fn eth(mut self, v: OutPoint) -> Self {
        self.eth = v;
        self
    }
    pub fn tron(mut self, v: OutPoint) -> Self {
        self.tron = v;
        self
    }
}
impl molecule::prelude::Builder for DasLockOutPointTableV1Builder {
    type Entity = DasLockOutPointTableV1;
    const NAME: &'static str = "DasLockOutPointTableV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.ckb_signall.as_slice().len()
            + self.ckb_multisign.as_slice().len()
            + self.ckb_anyone_can_pay.as_slice().len()
            + self.eth.as_slice().len()
            + self.tron.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.ckb_signall.as_slice().len();
        offsets.push(total_size);
        total_size += self.ckb_multisign.as_slice().len();
        offsets.push(total_size);
        total_size += self.ckb_anyone_can_pay.as_slice().len();
        offsets.push(total_size);
        total_size += self.eth.as_slice().len();
        offsets.push(total_size);
        total_size += self.tron.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.ckb_signall.as_slice())?;
        writer.write_all(self.ckb_multisign.as_slice())?;
        writer.write_all(self.ckb_anyone_can_pay.as_slice())?;
        writer.write_all(self.eth.as_slice())?;
        writer.write_all(self.tron.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DasLockOutPointTableV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV2 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            185, 1, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 237, 0, 0, 0, 0, 220, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0,
            0, 124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0,
            60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV2::new_unchecked(v.into())
    }
}
impl ConfigCellMainV2 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV2::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV2Reader<'r> {
        ConfigCellMainV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV2 {
    type Builder = ConfigCellMainV2Builder;
    const NAME: &'static str = "ConfigCellMainV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV2Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV2Reader<'r> {
    type Entity = ConfigCellMainV2;
    const NAME: &'static str = "ConfigCellMainV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableV1Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV2Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV2,
    pub(crate) das_lock_out_point_table: DasLockOutPointTableV1,
}
impl ConfigCellMainV2Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV2) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTableV1) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV2Builder {
    type Entity = ConfigCellMainV2;
    const NAME: &'static str = "ConfigCellMainV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV2 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            220, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV2::new_unchecked(v.into())
    }
}
impl TypeIdTableV2 {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV2Reader<'r> {
        TypeIdTableV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV2 {
    type Builder = TypeIdTableV2Builder;
    const NAME: &'static str = "TypeIdTableV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV2Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV2Reader<'r> {
    type Entity = TypeIdTableV2;
    const NAME: &'static str = "TypeIdTableV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV2Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
}
impl TypeIdTableV2Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV2Builder {
    type Entity = TypeIdTableV2;
    const NAME: &'static str = "TypeIdTableV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV3 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            1, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 53, 1, 0, 0, 0, 36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0,
            132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0,
            60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV3::new_unchecked(v.into())
    }
}
impl ConfigCellMainV3 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV3::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV3Reader<'r> {
        ConfigCellMainV3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV3 {
    type Builder = ConfigCellMainV3Builder;
    const NAME: &'static str = "ConfigCellMainV3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV3Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV3Reader<'r> {
    type Entity = ConfigCellMainV3;
    const NAME: &'static str = "ConfigCellMainV3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV3Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableV1Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV3Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV3,
    pub(crate) das_lock_out_point_table: DasLockOutPointTableV1,
}
impl ConfigCellMainV3Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV3) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTableV1) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV3Builder {
    type Entity = ConfigCellMainV3;
    const NAME: &'static str = "ConfigCellMainV3Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV3 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0, 132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0,
            0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV3::new_unchecked(v.into())
    }
}
impl TypeIdTableV3 {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV3Reader<'r> {
        TypeIdTableV3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV3 {
    type Builder = TypeIdTableV3Builder;
    const NAME: &'static str = "TypeIdTableV3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV3Reader<'r> {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV3Reader<'r> {
    type Entity = TypeIdTableV3;
    const NAME: &'static str = "TypeIdTableV3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV3Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
}
impl TypeIdTableV3Builder {
    pub const FIELD_COUNT: usize = 8;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV3Builder {
    type Entity = TypeIdTableV3;
    const NAME: &'static str = "TypeIdTableV3Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV4(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV4 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            73, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 125, 1, 0, 0, 0, 108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0,
            0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0,
            0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV4::new_unchecked(v.into())
    }
}
impl ConfigCellMainV4 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV4 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV4::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTableV1::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV4Reader<'r> {
        ConfigCellMainV4Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV4 {
    type Builder = ConfigCellMainV4Builder;
    const NAME: &'static str = "ConfigCellMainV4";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV4(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV4Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV4Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV4Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV4Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV4Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV4Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableV1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableV1Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV4Reader<'r> {
    type Entity = ConfigCellMainV4;
    const NAME: &'static str = "ConfigCellMainV4Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV4Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV4Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableV1Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV4Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV4,
    pub(crate) das_lock_out_point_table: DasLockOutPointTableV1,
}
impl ConfigCellMainV4Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV4) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTableV1) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV4Builder {
    type Entity = ConfigCellMainV4;
    const NAME: &'static str = "ConfigCellMainV4Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV4::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV5(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV5 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            153, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 125, 1, 0, 0, 0, 108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0,
            0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 1, 0, 0, 32, 0,
            0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV5::new_unchecked(v.into())
    }
}
impl ConfigCellMainV5 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV4 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV4::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV5Reader<'r> {
        ConfigCellMainV5Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV5 {
    type Builder = ConfigCellMainV5Builder;
    const NAME: &'static str = "ConfigCellMainV5";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV5(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV5Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV5Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV5Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV5Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV4Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV4Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV5Reader<'r> {
    type Entity = ConfigCellMainV5;
    const NAME: &'static str = "ConfigCellMainV5Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV5Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV4Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV5Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV4,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
}
impl ConfigCellMainV5Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV4) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV5Builder {
    type Entity = ConfigCellMainV5;
    const NAME: &'static str = "ConfigCellMainV5Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV5::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV4(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV4 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0,
            0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV4::new_unchecked(v.into())
    }
}
impl TypeIdTableV4 {
    pub const FIELD_COUNT: usize = 10;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV4Reader<'r> {
        TypeIdTableV4Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV4 {
    type Builder = TypeIdTableV4Builder;
    const NAME: &'static str = "TypeIdTableV4";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV4(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV4Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV4Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
            .offer_cell(self.offer_cell())
            .reverse_record_cell(self.reverse_record_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV4Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV4Reader<'r> {
    pub const FIELD_COUNT: usize = 10;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV4Reader<'r> {
    type Entity = TypeIdTableV4;
    const NAME: &'static str = "TypeIdTableV4Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV4Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        HashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        HashReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV4Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
    pub(crate) offer_cell: Hash,
    pub(crate) reverse_record_cell: Hash,
}
impl TypeIdTableV4Builder {
    pub const FIELD_COUNT: usize = 10;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
    pub fn offer_cell(mut self, v: Hash) -> Self {
        self.offer_cell = v;
        self
    }
    pub fn reverse_record_cell(mut self, v: Hash) -> Self {
        self.reverse_record_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV4Builder {
    type Entity = TypeIdTableV4;
    const NAME: &'static str = "TypeIdTableV4Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
            + self.offer_cell.as_slice().len()
            + self.reverse_record_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        writer.write_all(self.offer_cell.as_slice())?;
        writer.write_all(self.reverse_record_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV4::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV6(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV6 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            189, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 161, 1, 0, 0, 0, 144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0,
            0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0, 0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 1, 0, 0, 32,
            0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV6::new_unchecked(v.into())
    }
}
impl ConfigCellMainV6 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV5::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV6Reader<'r> {
        ConfigCellMainV6Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV6 {
    type Builder = ConfigCellMainV6Builder;
    const NAME: &'static str = "ConfigCellMainV6";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV6(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV6Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV6Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV6Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV6Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV5Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV6Reader<'r> {
    type Entity = ConfigCellMainV6;
    const NAME: &'static str = "ConfigCellMainV6Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV6Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV5Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV6Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV5,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
}
impl ConfigCellMainV6Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV5) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV6Builder {
    type Entity = ConfigCellMainV6;
    const NAME: &'static str = "ConfigCellMainV6Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV6::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV5(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV5 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0,
            0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV5::new_unchecked(v.into())
    }
}
impl TypeIdTableV5 {
    pub const FIELD_COUNT: usize = 11;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn sub_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[48..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV5Reader<'r> {
        TypeIdTableV5Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV5 {
    type Builder = TypeIdTableV5Builder;
    const NAME: &'static str = "TypeIdTableV5";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV5(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV5Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV5Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
            .offer_cell(self.offer_cell())
            .reverse_record_cell(self.reverse_record_cell())
            .sub_account_cell(self.sub_account_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV5Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV5Reader<'r> {
    pub const FIELD_COUNT: usize = 11;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sub_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[48..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV5Reader<'r> {
    type Entity = TypeIdTableV5;
    const NAME: &'static str = "TypeIdTableV5Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV5Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        HashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        HashReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        HashReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV5Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
    pub(crate) offer_cell: Hash,
    pub(crate) reverse_record_cell: Hash,
    pub(crate) sub_account_cell: Hash,
}
impl TypeIdTableV5Builder {
    pub const FIELD_COUNT: usize = 11;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
    pub fn offer_cell(mut self, v: Hash) -> Self {
        self.offer_cell = v;
        self
    }
    pub fn reverse_record_cell(mut self, v: Hash) -> Self {
        self.reverse_record_cell = v;
        self
    }
    pub fn sub_account_cell(mut self, v: Hash) -> Self {
        self.sub_account_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV5Builder {
    type Entity = TypeIdTableV5;
    const NAME: &'static str = "TypeIdTableV5Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
            + self.offer_cell.as_slice().len()
            + self.reverse_record_cell.as_slice().len()
            + self.sub_account_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.sub_account_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        writer.write_all(self.offer_cell.as_slice())?;
        writer.write_all(self.reverse_record_cell.as_slice())?;
        writer.write_all(self.sub_account_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV5::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV7(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV7 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            189, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 161, 1, 0, 0, 0, 144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0,
            0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0, 0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 1, 0, 0, 32,
            0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV7::new_unchecked(v.into())
    }
}
impl ConfigCellMainV7 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV5::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV7Reader<'r> {
        ConfigCellMainV7Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV7 {
    type Builder = ConfigCellMainV7Builder;
    const NAME: &'static str = "ConfigCellMainV7";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV7(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV7Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV7Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV7Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV7Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV5Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV7Reader<'r> {
    type Entity = ConfigCellMainV7;
    const NAME: &'static str = "ConfigCellMainV7Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV7Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV5Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV7Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV5,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
}
impl ConfigCellMainV7Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV5) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV7Builder {
    type Entity = ConfigCellMainV7;
    const NAME: &'static str = "ConfigCellMainV7Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV7::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV8(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV8 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            225, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 197, 1, 0, 0, 0, 180, 1, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 116, 0, 0,
            0, 148, 0, 0, 0, 180, 0, 0, 0, 212, 0, 0, 0, 244, 0, 0, 0, 20, 1, 0, 0, 52, 1, 0, 0, 84, 1, 0, 0, 116, 1,
            0, 0, 148, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 1, 0, 0,
            32, 0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV8::new_unchecked(v.into())
    }
}
impl ConfigCellMainV8 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV6 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV6::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV8Reader<'r> {
        ConfigCellMainV8Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV8 {
    type Builder = ConfigCellMainV8Builder;
    const NAME: &'static str = "ConfigCellMainV8";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV8(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV8Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV8Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV8Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV8Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV6Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV6Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV8Reader<'r> {
    type Entity = ConfigCellMainV8;
    const NAME: &'static str = "ConfigCellMainV8Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV8Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV6Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV8Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV6,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
}
impl ConfigCellMainV8Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV6) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV8Builder {
    type Entity = ConfigCellMainV8;
    const NAME: &'static str = "ConfigCellMainV8Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV8::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV6(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV6 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            180, 1, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 116, 0, 0, 0, 148, 0, 0, 0, 180, 0, 0, 0, 212, 0, 0, 0, 244, 0, 0,
            0, 20, 1, 0, 0, 52, 1, 0, 0, 84, 1, 0, 0, 116, 1, 0, 0, 148, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV6::new_unchecked(v.into())
    }
}
impl TypeIdTableV6 {
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn sub_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn eip712_lib(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV6Reader<'r> {
        TypeIdTableV6Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV6 {
    type Builder = TypeIdTableV6Builder;
    const NAME: &'static str = "TypeIdTableV6";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV6(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV6Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV6Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
            .offer_cell(self.offer_cell())
            .reverse_record_cell(self.reverse_record_cell())
            .sub_account_cell(self.sub_account_cell())
            .eip712_lib(self.eip712_lib())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV6Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV6Reader<'r> {
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sub_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn eip712_lib(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV6Reader<'r> {
    type Entity = TypeIdTableV6;
    const NAME: &'static str = "TypeIdTableV6Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV6Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        HashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        HashReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        HashReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        HashReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV6Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
    pub(crate) offer_cell: Hash,
    pub(crate) reverse_record_cell: Hash,
    pub(crate) sub_account_cell: Hash,
    pub(crate) eip712_lib: Hash,
}
impl TypeIdTableV6Builder {
    pub const FIELD_COUNT: usize = 12;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
    pub fn offer_cell(mut self, v: Hash) -> Self {
        self.offer_cell = v;
        self
    }
    pub fn reverse_record_cell(mut self, v: Hash) -> Self {
        self.reverse_record_cell = v;
        self
    }
    pub fn sub_account_cell(mut self, v: Hash) -> Self {
        self.sub_account_cell = v;
        self
    }
    pub fn eip712_lib(mut self, v: Hash) -> Self {
        self.eip712_lib = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV6Builder {
    type Entity = TypeIdTableV6;
    const NAME: &'static str = "TypeIdTableV6Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
            + self.offer_cell.as_slice().len()
            + self.reverse_record_cell.as_slice().len()
            + self.sub_account_cell.as_slice().len()
            + self.eip712_lib.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.sub_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.eip712_lib.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        writer.write_all(self.offer_cell.as_slice())?;
        writer.write_all(self.reverse_record_cell.as_slice())?;
        writer.write_all(self.sub_account_cell.as_slice())?;
        writer.write_all(self.eip712_lib.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV6::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV9(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV9 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            5, 3, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 233, 1, 0, 0, 0, 216, 1, 0, 0, 56, 0, 0, 0, 88, 0, 0, 0, 120, 0, 0,
            0, 152, 0, 0, 0, 184, 0, 0, 0, 216, 0, 0, 0, 248, 0, 0, 0, 24, 1, 0, 0, 56, 1, 0, 0, 88, 1, 0, 0, 120, 1,
            0, 0, 152, 1, 0, 0, 184, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 1, 0,
            0, 32, 0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV9::new_unchecked(v.into())
    }
}
impl ConfigCellMainV9 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV7 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV7::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockOutPointTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV9Reader<'r> {
        ConfigCellMainV9Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV9 {
    type Builder = ConfigCellMainV9Builder;
    const NAME: &'static str = "ConfigCellMainV9";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV9(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV9Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV9Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV9Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV9Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV7Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV7Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV9Reader<'r> {
    type Entity = ConfigCellMainV9;
    const NAME: &'static str = "ConfigCellMainV9Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV9Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV7Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV9Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV7,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
}
impl ConfigCellMainV9Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV7) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV9Builder {
    type Entity = ConfigCellMainV9;
    const NAME: &'static str = "ConfigCellMainV9Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV9::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV7(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell",
            self.reverse_record_root_cell()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV7 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            216, 1, 0, 0, 56, 0, 0, 0, 88, 0, 0, 0, 120, 0, 0, 0, 152, 0, 0, 0, 184, 0, 0, 0, 216, 0, 0, 0, 248, 0, 0,
            0, 24, 1, 0, 0, 56, 1, 0, 0, 88, 1, 0, 0, 120, 1, 0, 0, 152, 1, 0, 0, 184, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV7::new_unchecked(v.into())
    }
}
impl TypeIdTableV7 {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn sub_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn eip712_lib(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_root_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV7Reader<'r> {
        TypeIdTableV7Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV7 {
    type Builder = TypeIdTableV7Builder;
    const NAME: &'static str = "TypeIdTableV7";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV7(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV7Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV7Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
            .offer_cell(self.offer_cell())
            .reverse_record_cell(self.reverse_record_cell())
            .sub_account_cell(self.sub_account_cell())
            .eip712_lib(self.eip712_lib())
            .reverse_record_root_cell(self.reverse_record_root_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV7Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell",
            self.reverse_record_root_cell()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV7Reader<'r> {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sub_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn eip712_lib(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_root_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV7Reader<'r> {
    type Entity = TypeIdTableV7;
    const NAME: &'static str = "TypeIdTableV7Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV7Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        HashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        HashReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        HashReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        HashReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        HashReader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV7Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
    pub(crate) offer_cell: Hash,
    pub(crate) reverse_record_cell: Hash,
    pub(crate) sub_account_cell: Hash,
    pub(crate) eip712_lib: Hash,
    pub(crate) reverse_record_root_cell: Hash,
}
impl TypeIdTableV7Builder {
    pub const FIELD_COUNT: usize = 13;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
    pub fn offer_cell(mut self, v: Hash) -> Self {
        self.offer_cell = v;
        self
    }
    pub fn reverse_record_cell(mut self, v: Hash) -> Self {
        self.reverse_record_cell = v;
        self
    }
    pub fn sub_account_cell(mut self, v: Hash) -> Self {
        self.sub_account_cell = v;
        self
    }
    pub fn eip712_lib(mut self, v: Hash) -> Self {
        self.eip712_lib = v;
        self
    }
    pub fn reverse_record_root_cell(mut self, v: Hash) -> Self {
        self.reverse_record_root_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV7Builder {
    type Entity = TypeIdTableV7;
    const NAME: &'static str = "TypeIdTableV7Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
            + self.offer_cell.as_slice().len()
            + self.reverse_record_cell.as_slice().len()
            + self.sub_account_cell.as_slice().len()
            + self.eip712_lib.as_slice().len()
            + self.reverse_record_root_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.sub_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.eip712_lib.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_root_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        writer.write_all(self.offer_cell.as_slice())?;
        writer.write_all(self.reverse_record_cell.as_slice())?;
        writer.write_all(self.sub_account_cell.as_slice())?;
        writer.write_all(self.eip712_lib.as_slice())?;
        writer.write_all(self.reverse_record_root_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV7::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV10(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        write!(f, ", {}: {}", "das_lock_type_id_table", self.das_lock_type_id_table())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV10 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            9, 4, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 237, 1, 0, 0, 9, 3, 0, 0, 0, 216, 1, 0, 0, 56, 0, 0, 0, 88, 0, 0, 0,
            120, 0, 0, 0, 152, 0, 0, 0, 184, 0, 0, 0, 216, 0, 0, 0, 248, 0, 0, 0, 24, 1, 0, 0, 56, 1, 0, 0, 88, 1, 0,
            0, 120, 1, 0, 0, 152, 1, 0, 0, 184, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            28, 1, 0, 0, 32, 0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV10::new_unchecked(v.into())
    }
}
impl ConfigCellMainV10 {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV7 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV7::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_type_id_table(&self) -> DasLockTypeIdTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            DasLockTypeIdTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockTypeIdTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV10Reader<'r> {
        ConfigCellMainV10Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV10 {
    type Builder = ConfigCellMainV10Builder;
    const NAME: &'static str = "ConfigCellMainV10";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV10(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV10Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV10Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
            .das_lock_type_id_table(self.das_lock_type_id_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV10Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        write!(f, ", {}: {}", "das_lock_type_id_table", self.das_lock_type_id_table())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV10Reader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV7Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV7Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_type_id_table(&self) -> DasLockTypeIdTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            DasLockTypeIdTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockTypeIdTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV10Reader<'r> {
    type Entity = ConfigCellMainV10;
    const NAME: &'static str = "ConfigCellMainV10Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV10Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV7Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        DasLockTypeIdTableReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV10Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV7,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
    pub(crate) das_lock_type_id_table: DasLockTypeIdTable,
}
impl ConfigCellMainV10Builder {
    pub const FIELD_COUNT: usize = 4;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV7) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
    pub fn das_lock_type_id_table(mut self, v: DasLockTypeIdTable) -> Self {
        self.das_lock_type_id_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV10Builder {
    type Entity = ConfigCellMainV10;
    const NAME: &'static str = "ConfigCellMainV10Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
            + self.das_lock_type_id_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_type_id_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        writer.write_all(self.das_lock_type_id_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV10::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellMainV11(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellMainV11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellMainV11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellMainV11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        write!(f, ", {}: {}", "das_lock_type_id_table", self.das_lock_type_id_table())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellMainV11 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            45, 4, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 17, 2, 0, 0, 45, 3, 0, 0, 0, 252, 1, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0,
            124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 220, 0, 0, 0, 252, 0, 0, 0, 28, 1, 0, 0, 60, 1, 0, 0, 92, 1, 0,
            0, 124, 1, 0, 0, 156, 1, 0, 0, 188, 1, 0, 0, 220, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            28, 1, 0, 0, 32, 0, 0, 0, 68, 0, 0, 0, 104, 0, 0, 0, 140, 0, 0, 0, 176, 0, 0, 0, 212, 0, 0, 0, 248, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellMainV11::new_unchecked(v.into())
    }
}
impl ConfigCellMainV11 {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }
    pub fn type_id_table(&self) -> TypeIdTableV8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV8::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DasLockOutPointTable::new_unchecked(self.0.slice(start..end))
    }
    pub fn das_lock_type_id_table(&self) -> DasLockTypeIdTable {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            DasLockTypeIdTable::new_unchecked(self.0.slice(start..end))
        } else {
            DasLockTypeIdTable::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellMainV11Reader<'r> {
        ConfigCellMainV11Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellMainV11 {
    type Builder = ConfigCellMainV11Builder;
    const NAME: &'static str = "ConfigCellMainV11";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellMainV11(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV11Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellMainV11Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .status(self.status())
            .type_id_table(self.type_id_table())
            .das_lock_out_point_table(self.das_lock_out_point_table())
            .das_lock_type_id_table(self.das_lock_type_id_table())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellMainV11Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellMainV11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellMainV11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellMainV11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "status", self.status())?;
        write!(f, ", {}: {}", "type_id_table", self.type_id_table())?;
        write!(
            f,
            ", {}: {}",
            "das_lock_out_point_table",
            self.das_lock_out_point_table()
        )?;
        write!(f, ", {}: {}", "das_lock_type_id_table", self.das_lock_type_id_table())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellMainV11Reader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn status(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn type_id_table(&self) -> TypeIdTableV8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TypeIdTableV8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_out_point_table(&self) -> DasLockOutPointTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DasLockOutPointTableReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn das_lock_type_id_table(&self) -> DasLockTypeIdTableReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            DasLockTypeIdTableReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            DasLockTypeIdTableReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellMainV11Reader<'r> {
    type Entity = ConfigCellMainV11;
    const NAME: &'static str = "ConfigCellMainV11Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellMainV11Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TypeIdTableV8Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DasLockOutPointTableReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        DasLockTypeIdTableReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellMainV11Builder {
    pub(crate) status: Uint8,
    pub(crate) type_id_table: TypeIdTableV8,
    pub(crate) das_lock_out_point_table: DasLockOutPointTable,
    pub(crate) das_lock_type_id_table: DasLockTypeIdTable,
}
impl ConfigCellMainV11Builder {
    pub const FIELD_COUNT: usize = 4;
    pub fn status(mut self, v: Uint8) -> Self {
        self.status = v;
        self
    }
    pub fn type_id_table(mut self, v: TypeIdTableV8) -> Self {
        self.type_id_table = v;
        self
    }
    pub fn das_lock_out_point_table(mut self, v: DasLockOutPointTable) -> Self {
        self.das_lock_out_point_table = v;
        self
    }
    pub fn das_lock_type_id_table(mut self, v: DasLockTypeIdTable) -> Self {
        self.das_lock_type_id_table = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellMainV11Builder {
    type Entity = ConfigCellMainV11;
    const NAME: &'static str = "ConfigCellMainV11Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.status.as_slice().len()
            + self.type_id_table.as_slice().len()
            + self.das_lock_out_point_table.as_slice().len()
            + self.das_lock_type_id_table.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.status.as_slice().len();
        offsets.push(total_size);
        total_size += self.type_id_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_out_point_table.as_slice().len();
        offsets.push(total_size);
        total_size += self.das_lock_type_id_table.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.status.as_slice())?;
        writer.write_all(self.type_id_table.as_slice())?;
        writer.write_all(self.das_lock_out_point_table.as_slice())?;
        writer.write_all(self.das_lock_type_id_table.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellMainV11::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TypeIdTableV8(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TypeIdTableV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TypeIdTableV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TypeIdTableV8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell",
            self.reverse_record_root_cell()
        )?;
        write!(f, ", {}: {}", "key_list_config_cell", self.key_list_config_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TypeIdTableV8 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            252, 1, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 220, 0, 0, 0, 252, 0, 0,
            0, 28, 1, 0, 0, 60, 1, 0, 0, 92, 1, 0, 0, 124, 1, 0, 0, 156, 1, 0, 0, 188, 1, 0, 0, 220, 1, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TypeIdTableV8::new_unchecked(v.into())
    }
}
impl TypeIdTableV8 {
    pub const FIELD_COUNT: usize = 14;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn apply_register_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_auction_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn sub_account_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn eip712_lib(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_root_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        Hash::new_unchecked(self.0.slice(start..end))
    }
    pub fn key_list_config_cell(&self) -> Hash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[60..]) as usize;
            Hash::new_unchecked(self.0.slice(start..end))
        } else {
            Hash::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TypeIdTableV8Reader<'r> {
        TypeIdTableV8Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TypeIdTableV8 {
    type Builder = TypeIdTableV8Builder;
    const NAME: &'static str = "TypeIdTableV8";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TypeIdTableV8(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV8Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TypeIdTableV8Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .account_cell(self.account_cell())
            .apply_register_cell(self.apply_register_cell())
            .balance_cell(self.balance_cell())
            .income_cell(self.income_cell())
            .pre_account_cell(self.pre_account_cell())
            .proposal_cell(self.proposal_cell())
            .account_sale_cell(self.account_sale_cell())
            .account_auction_cell(self.account_auction_cell())
            .offer_cell(self.offer_cell())
            .reverse_record_cell(self.reverse_record_cell())
            .sub_account_cell(self.sub_account_cell())
            .eip712_lib(self.eip712_lib())
            .reverse_record_root_cell(self.reverse_record_root_cell())
            .key_list_config_cell(self.key_list_config_cell())
    }
}
#[derive(Clone, Copy)]
pub struct TypeIdTableV8Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TypeIdTableV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TypeIdTableV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TypeIdTableV8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "account_cell", self.account_cell())?;
        write!(f, ", {}: {}", "apply_register_cell", self.apply_register_cell())?;
        write!(f, ", {}: {}", "balance_cell", self.balance_cell())?;
        write!(f, ", {}: {}", "income_cell", self.income_cell())?;
        write!(f, ", {}: {}", "pre_account_cell", self.pre_account_cell())?;
        write!(f, ", {}: {}", "proposal_cell", self.proposal_cell())?;
        write!(f, ", {}: {}", "account_sale_cell", self.account_sale_cell())?;
        write!(f, ", {}: {}", "account_auction_cell", self.account_auction_cell())?;
        write!(f, ", {}: {}", "offer_cell", self.offer_cell())?;
        write!(f, ", {}: {}", "reverse_record_cell", self.reverse_record_cell())?;
        write!(f, ", {}: {}", "sub_account_cell", self.sub_account_cell())?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell",
            self.reverse_record_root_cell()
        )?;
        write!(f, ", {}: {}", "key_list_config_cell", self.key_list_config_cell())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TypeIdTableV8Reader<'r> {
    pub const FIELD_COUNT: usize = 14;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn apply_register_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_auction_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sub_account_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn eip712_lib(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_root_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        HashReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn key_list_config_cell(&self) -> HashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[60..]) as usize;
            HashReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HashReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TypeIdTableV8Reader<'r> {
    type Entity = TypeIdTableV8;
    const NAME: &'static str = "TypeIdTableV8Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TypeIdTableV8Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HashReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HashReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HashReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HashReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        HashReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        HashReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        HashReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        HashReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        HashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        HashReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        HashReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        HashReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        HashReader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        HashReader::verify(&slice[offsets[13]..offsets[14]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TypeIdTableV8Builder {
    pub(crate) account_cell: Hash,
    pub(crate) apply_register_cell: Hash,
    pub(crate) balance_cell: Hash,
    pub(crate) income_cell: Hash,
    pub(crate) pre_account_cell: Hash,
    pub(crate) proposal_cell: Hash,
    pub(crate) account_sale_cell: Hash,
    pub(crate) account_auction_cell: Hash,
    pub(crate) offer_cell: Hash,
    pub(crate) reverse_record_cell: Hash,
    pub(crate) sub_account_cell: Hash,
    pub(crate) eip712_lib: Hash,
    pub(crate) reverse_record_root_cell: Hash,
    pub(crate) key_list_config_cell: Hash,
}
impl TypeIdTableV8Builder {
    pub const FIELD_COUNT: usize = 14;
    pub fn account_cell(mut self, v: Hash) -> Self {
        self.account_cell = v;
        self
    }
    pub fn apply_register_cell(mut self, v: Hash) -> Self {
        self.apply_register_cell = v;
        self
    }
    pub fn balance_cell(mut self, v: Hash) -> Self {
        self.balance_cell = v;
        self
    }
    pub fn income_cell(mut self, v: Hash) -> Self {
        self.income_cell = v;
        self
    }
    pub fn pre_account_cell(mut self, v: Hash) -> Self {
        self.pre_account_cell = v;
        self
    }
    pub fn proposal_cell(mut self, v: Hash) -> Self {
        self.proposal_cell = v;
        self
    }
    pub fn account_sale_cell(mut self, v: Hash) -> Self {
        self.account_sale_cell = v;
        self
    }
    pub fn account_auction_cell(mut self, v: Hash) -> Self {
        self.account_auction_cell = v;
        self
    }
    pub fn offer_cell(mut self, v: Hash) -> Self {
        self.offer_cell = v;
        self
    }
    pub fn reverse_record_cell(mut self, v: Hash) -> Self {
        self.reverse_record_cell = v;
        self
    }
    pub fn sub_account_cell(mut self, v: Hash) -> Self {
        self.sub_account_cell = v;
        self
    }
    pub fn eip712_lib(mut self, v: Hash) -> Self {
        self.eip712_lib = v;
        self
    }
    pub fn reverse_record_root_cell(mut self, v: Hash) -> Self {
        self.reverse_record_root_cell = v;
        self
    }
    pub fn key_list_config_cell(mut self, v: Hash) -> Self {
        self.key_list_config_cell = v;
        self
    }
}
impl molecule::prelude::Builder for TypeIdTableV8Builder {
    type Entity = TypeIdTableV8;
    const NAME: &'static str = "TypeIdTableV8Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.account_cell.as_slice().len()
            + self.apply_register_cell.as_slice().len()
            + self.balance_cell.as_slice().len()
            + self.income_cell.as_slice().len()
            + self.pre_account_cell.as_slice().len()
            + self.proposal_cell.as_slice().len()
            + self.account_sale_cell.as_slice().len()
            + self.account_auction_cell.as_slice().len()
            + self.offer_cell.as_slice().len()
            + self.reverse_record_cell.as_slice().len()
            + self.sub_account_cell.as_slice().len()
            + self.eip712_lib.as_slice().len()
            + self.reverse_record_root_cell.as_slice().len()
            + self.key_list_config_cell.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.apply_register_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_auction_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.sub_account_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.eip712_lib.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_root_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.key_list_config_cell.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.account_cell.as_slice())?;
        writer.write_all(self.apply_register_cell.as_slice())?;
        writer.write_all(self.balance_cell.as_slice())?;
        writer.write_all(self.income_cell.as_slice())?;
        writer.write_all(self.pre_account_cell.as_slice())?;
        writer.write_all(self.proposal_cell.as_slice())?;
        writer.write_all(self.account_sale_cell.as_slice())?;
        writer.write_all(self.account_auction_cell.as_slice())?;
        writer.write_all(self.offer_cell.as_slice())?;
        writer.write_all(self.reverse_record_cell.as_slice())?;
        writer.write_all(self.sub_account_cell.as_slice())?;
        writer.write_all(self.eip712_lib.as_slice())?;
        writer.write_all(self.reverse_record_root_cell.as_slice())?;
        writer.write_all(self.key_list_config_cell.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TypeIdTableV8::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellAccountV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "max_length", self.max_length())?;
        write!(f, ", {}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "expiration_grace_period", self.expiration_grace_period())?;
        write!(f, ", {}: {}", "record_min_ttl", self.record_min_ttl())?;
        write!(f, ", {}: {}", "record_size_limit", self.record_size_limit())?;
        write!(f, ", {}: {}", "transfer_account_fee", self.transfer_account_fee())?;
        write!(f, ", {}: {}", "edit_manager_fee", self.edit_manager_fee())?;
        write!(f, ", {}: {}", "edit_records_fee", self.edit_records_fee())?;
        write!(
            f,
            ", {}: {}",
            "transfer_account_throttle",
            self.transfer_account_throttle()
        )?;
        write!(f, ", {}: {}", "edit_manager_throttle", self.edit_manager_throttle())?;
        write!(f, ", {}: {}", "edit_records_throttle", self.edit_records_throttle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellAccountV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            120, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0,
            92, 0, 0, 0, 100, 0, 0, 0, 108, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellAccountV1::new_unchecked(v.into())
    }
}
impl ConfigCellAccountV1 {
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn max_length(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn basic_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn prepared_fee_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn expiration_grace_period(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn record_min_ttl(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn record_size_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transfer_account_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_manager_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_records_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn transfer_account_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_manager_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_records_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellAccountV1Reader<'r> {
        ConfigCellAccountV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellAccountV1 {
    type Builder = ConfigCellAccountV1Builder;
    const NAME: &'static str = "ConfigCellAccountV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellAccountV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellAccountV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellAccountV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .max_length(self.max_length())
            .basic_capacity(self.basic_capacity())
            .prepared_fee_capacity(self.prepared_fee_capacity())
            .expiration_grace_period(self.expiration_grace_period())
            .record_min_ttl(self.record_min_ttl())
            .record_size_limit(self.record_size_limit())
            .transfer_account_fee(self.transfer_account_fee())
            .edit_manager_fee(self.edit_manager_fee())
            .edit_records_fee(self.edit_records_fee())
            .transfer_account_throttle(self.transfer_account_throttle())
            .edit_manager_throttle(self.edit_manager_throttle())
            .edit_records_throttle(self.edit_records_throttle())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellAccountV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "max_length", self.max_length())?;
        write!(f, ", {}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "expiration_grace_period", self.expiration_grace_period())?;
        write!(f, ", {}: {}", "record_min_ttl", self.record_min_ttl())?;
        write!(f, ", {}: {}", "record_size_limit", self.record_size_limit())?;
        write!(f, ", {}: {}", "transfer_account_fee", self.transfer_account_fee())?;
        write!(f, ", {}: {}", "edit_manager_fee", self.edit_manager_fee())?;
        write!(f, ", {}: {}", "edit_records_fee", self.edit_records_fee())?;
        write!(
            f,
            ", {}: {}",
            "transfer_account_throttle",
            self.transfer_account_throttle()
        )?;
        write!(f, ", {}: {}", "edit_manager_throttle", self.edit_manager_throttle())?;
        write!(f, ", {}: {}", "edit_records_throttle", self.edit_records_throttle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellAccountV1Reader<'r> {
    pub const FIELD_COUNT: usize = 12;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn max_length(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn basic_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prepared_fee_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn expiration_grace_period(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn record_min_ttl(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn record_size_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transfer_account_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_manager_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_records_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transfer_account_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_manager_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_records_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[52..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellAccountV1Reader<'r> {
    type Entity = ConfigCellAccountV1;
    const NAME: &'static str = "ConfigCellAccountV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellAccountV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint32Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint64Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Uint64Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Uint32Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Uint32Reader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        Uint32Reader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellAccountV1Builder {
    pub(crate) max_length: Uint32,
    pub(crate) basic_capacity: Uint64,
    pub(crate) prepared_fee_capacity: Uint64,
    pub(crate) expiration_grace_period: Uint32,
    pub(crate) record_min_ttl: Uint32,
    pub(crate) record_size_limit: Uint32,
    pub(crate) transfer_account_fee: Uint64,
    pub(crate) edit_manager_fee: Uint64,
    pub(crate) edit_records_fee: Uint64,
    pub(crate) transfer_account_throttle: Uint32,
    pub(crate) edit_manager_throttle: Uint32,
    pub(crate) edit_records_throttle: Uint32,
}
impl ConfigCellAccountV1Builder {
    pub const FIELD_COUNT: usize = 12;
    pub fn max_length(mut self, v: Uint32) -> Self {
        self.max_length = v;
        self
    }
    pub fn basic_capacity(mut self, v: Uint64) -> Self {
        self.basic_capacity = v;
        self
    }
    pub fn prepared_fee_capacity(mut self, v: Uint64) -> Self {
        self.prepared_fee_capacity = v;
        self
    }
    pub fn expiration_grace_period(mut self, v: Uint32) -> Self {
        self.expiration_grace_period = v;
        self
    }
    pub fn record_min_ttl(mut self, v: Uint32) -> Self {
        self.record_min_ttl = v;
        self
    }
    pub fn record_size_limit(mut self, v: Uint32) -> Self {
        self.record_size_limit = v;
        self
    }
    pub fn transfer_account_fee(mut self, v: Uint64) -> Self {
        self.transfer_account_fee = v;
        self
    }
    pub fn edit_manager_fee(mut self, v: Uint64) -> Self {
        self.edit_manager_fee = v;
        self
    }
    pub fn edit_records_fee(mut self, v: Uint64) -> Self {
        self.edit_records_fee = v;
        self
    }
    pub fn transfer_account_throttle(mut self, v: Uint32) -> Self {
        self.transfer_account_throttle = v;
        self
    }
    pub fn edit_manager_throttle(mut self, v: Uint32) -> Self {
        self.edit_manager_throttle = v;
        self
    }
    pub fn edit_records_throttle(mut self, v: Uint32) -> Self {
        self.edit_records_throttle = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellAccountV1Builder {
    type Entity = ConfigCellAccountV1;
    const NAME: &'static str = "ConfigCellAccountV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.max_length.as_slice().len()
            + self.basic_capacity.as_slice().len()
            + self.prepared_fee_capacity.as_slice().len()
            + self.expiration_grace_period.as_slice().len()
            + self.record_min_ttl.as_slice().len()
            + self.record_size_limit.as_slice().len()
            + self.transfer_account_fee.as_slice().len()
            + self.edit_manager_fee.as_slice().len()
            + self.edit_records_fee.as_slice().len()
            + self.transfer_account_throttle.as_slice().len()
            + self.edit_manager_throttle.as_slice().len()
            + self.edit_records_throttle.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.max_length.as_slice().len();
        offsets.push(total_size);
        total_size += self.basic_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.prepared_fee_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.expiration_grace_period.as_slice().len();
        offsets.push(total_size);
        total_size += self.record_min_ttl.as_slice().len();
        offsets.push(total_size);
        total_size += self.record_size_limit.as_slice().len();
        offsets.push(total_size);
        total_size += self.transfer_account_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_manager_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_records_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.transfer_account_throttle.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_manager_throttle.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_records_throttle.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.max_length.as_slice())?;
        writer.write_all(self.basic_capacity.as_slice())?;
        writer.write_all(self.prepared_fee_capacity.as_slice())?;
        writer.write_all(self.expiration_grace_period.as_slice())?;
        writer.write_all(self.record_min_ttl.as_slice())?;
        writer.write_all(self.record_size_limit.as_slice())?;
        writer.write_all(self.transfer_account_fee.as_slice())?;
        writer.write_all(self.edit_manager_fee.as_slice())?;
        writer.write_all(self.edit_records_fee.as_slice())?;
        writer.write_all(self.transfer_account_throttle.as_slice())?;
        writer.write_all(self.edit_manager_throttle.as_slice())?;
        writer.write_all(self.edit_records_throttle.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellAccountV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellAccountV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellAccountV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellAccountV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellAccountV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "max_length", self.max_length())?;
        write!(f, ", {}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "expiration_grace_period", self.expiration_grace_period())?;
        write!(f, ", {}: {}", "record_min_ttl", self.record_min_ttl())?;
        write!(f, ", {}: {}", "record_size_limit", self.record_size_limit())?;
        write!(f, ", {}: {}", "transfer_account_fee", self.transfer_account_fee())?;
        write!(f, ", {}: {}", "edit_manager_fee", self.edit_manager_fee())?;
        write!(f, ", {}: {}", "edit_records_fee", self.edit_records_fee())?;
        write!(
            f,
            ", {}: {}",
            "transfer_account_throttle",
            self.transfer_account_throttle()
        )?;
        write!(f, ", {}: {}", "edit_manager_throttle", self.edit_manager_throttle())?;
        write!(f, ", {}: {}", "edit_records_throttle", self.edit_records_throttle())?;
        write!(f, ", {}: {}", "common_throttle", self.common_throttle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellAccountV2 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            128, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 68, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0,
            96, 0, 0, 0, 104, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 120, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellAccountV2::new_unchecked(v.into())
    }
}
impl ConfigCellAccountV2 {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn max_length(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn basic_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn prepared_fee_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn expiration_grace_period(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn record_min_ttl(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn record_size_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transfer_account_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_manager_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_records_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn transfer_account_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_manager_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_records_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn common_throttle(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellAccountV2Reader<'r> {
        ConfigCellAccountV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellAccountV2 {
    type Builder = ConfigCellAccountV2Builder;
    const NAME: &'static str = "ConfigCellAccountV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellAccountV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellAccountV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellAccountV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .max_length(self.max_length())
            .basic_capacity(self.basic_capacity())
            .prepared_fee_capacity(self.prepared_fee_capacity())
            .expiration_grace_period(self.expiration_grace_period())
            .record_min_ttl(self.record_min_ttl())
            .record_size_limit(self.record_size_limit())
            .transfer_account_fee(self.transfer_account_fee())
            .edit_manager_fee(self.edit_manager_fee())
            .edit_records_fee(self.edit_records_fee())
            .transfer_account_throttle(self.transfer_account_throttle())
            .edit_manager_throttle(self.edit_manager_throttle())
            .edit_records_throttle(self.edit_records_throttle())
            .common_throttle(self.common_throttle())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellAccountV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellAccountV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellAccountV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellAccountV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "max_length", self.max_length())?;
        write!(f, ", {}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "expiration_grace_period", self.expiration_grace_period())?;
        write!(f, ", {}: {}", "record_min_ttl", self.record_min_ttl())?;
        write!(f, ", {}: {}", "record_size_limit", self.record_size_limit())?;
        write!(f, ", {}: {}", "transfer_account_fee", self.transfer_account_fee())?;
        write!(f, ", {}: {}", "edit_manager_fee", self.edit_manager_fee())?;
        write!(f, ", {}: {}", "edit_records_fee", self.edit_records_fee())?;
        write!(
            f,
            ", {}: {}",
            "transfer_account_throttle",
            self.transfer_account_throttle()
        )?;
        write!(f, ", {}: {}", "edit_manager_throttle", self.edit_manager_throttle())?;
        write!(f, ", {}: {}", "edit_records_throttle", self.edit_records_throttle())?;
        write!(f, ", {}: {}", "common_throttle", self.common_throttle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellAccountV2Reader<'r> {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn max_length(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn basic_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prepared_fee_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn expiration_grace_period(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn record_min_ttl(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn record_size_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transfer_account_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_manager_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_records_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transfer_account_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_manager_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_records_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn common_throttle(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellAccountV2Reader<'r> {
    type Entity = ConfigCellAccountV2;
    const NAME: &'static str = "ConfigCellAccountV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellAccountV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint32Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint64Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Uint64Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Uint32Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Uint32Reader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        Uint32Reader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        Uint32Reader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellAccountV2Builder {
    pub(crate) max_length: Uint32,
    pub(crate) basic_capacity: Uint64,
    pub(crate) prepared_fee_capacity: Uint64,
    pub(crate) expiration_grace_period: Uint32,
    pub(crate) record_min_ttl: Uint32,
    pub(crate) record_size_limit: Uint32,
    pub(crate) transfer_account_fee: Uint64,
    pub(crate) edit_manager_fee: Uint64,
    pub(crate) edit_records_fee: Uint64,
    pub(crate) transfer_account_throttle: Uint32,
    pub(crate) edit_manager_throttle: Uint32,
    pub(crate) edit_records_throttle: Uint32,
    pub(crate) common_throttle: Uint32,
}
impl ConfigCellAccountV2Builder {
    pub const FIELD_COUNT: usize = 13;
    pub fn max_length(mut self, v: Uint32) -> Self {
        self.max_length = v;
        self
    }
    pub fn basic_capacity(mut self, v: Uint64) -> Self {
        self.basic_capacity = v;
        self
    }
    pub fn prepared_fee_capacity(mut self, v: Uint64) -> Self {
        self.prepared_fee_capacity = v;
        self
    }
    pub fn expiration_grace_period(mut self, v: Uint32) -> Self {
        self.expiration_grace_period = v;
        self
    }
    pub fn record_min_ttl(mut self, v: Uint32) -> Self {
        self.record_min_ttl = v;
        self
    }
    pub fn record_size_limit(mut self, v: Uint32) -> Self {
        self.record_size_limit = v;
        self
    }
    pub fn transfer_account_fee(mut self, v: Uint64) -> Self {
        self.transfer_account_fee = v;
        self
    }
    pub fn edit_manager_fee(mut self, v: Uint64) -> Self {
        self.edit_manager_fee = v;
        self
    }
    pub fn edit_records_fee(mut self, v: Uint64) -> Self {
        self.edit_records_fee = v;
        self
    }
    pub fn transfer_account_throttle(mut self, v: Uint32) -> Self {
        self.transfer_account_throttle = v;
        self
    }
    pub fn edit_manager_throttle(mut self, v: Uint32) -> Self {
        self.edit_manager_throttle = v;
        self
    }
    pub fn edit_records_throttle(mut self, v: Uint32) -> Self {
        self.edit_records_throttle = v;
        self
    }
    pub fn common_throttle(mut self, v: Uint32) -> Self {
        self.common_throttle = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellAccountV2Builder {
    type Entity = ConfigCellAccountV2;
    const NAME: &'static str = "ConfigCellAccountV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.max_length.as_slice().len()
            + self.basic_capacity.as_slice().len()
            + self.prepared_fee_capacity.as_slice().len()
            + self.expiration_grace_period.as_slice().len()
            + self.record_min_ttl.as_slice().len()
            + self.record_size_limit.as_slice().len()
            + self.transfer_account_fee.as_slice().len()
            + self.edit_manager_fee.as_slice().len()
            + self.edit_records_fee.as_slice().len()
            + self.transfer_account_throttle.as_slice().len()
            + self.edit_manager_throttle.as_slice().len()
            + self.edit_records_throttle.as_slice().len()
            + self.common_throttle.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.max_length.as_slice().len();
        offsets.push(total_size);
        total_size += self.basic_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.prepared_fee_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.expiration_grace_period.as_slice().len();
        offsets.push(total_size);
        total_size += self.record_min_ttl.as_slice().len();
        offsets.push(total_size);
        total_size += self.record_size_limit.as_slice().len();
        offsets.push(total_size);
        total_size += self.transfer_account_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_manager_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_records_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.transfer_account_throttle.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_manager_throttle.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_records_throttle.as_slice().len();
        offsets.push(total_size);
        total_size += self.common_throttle.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.max_length.as_slice())?;
        writer.write_all(self.basic_capacity.as_slice())?;
        writer.write_all(self.prepared_fee_capacity.as_slice())?;
        writer.write_all(self.expiration_grace_period.as_slice())?;
        writer.write_all(self.record_min_ttl.as_slice())?;
        writer.write_all(self.record_size_limit.as_slice())?;
        writer.write_all(self.transfer_account_fee.as_slice())?;
        writer.write_all(self.edit_manager_fee.as_slice())?;
        writer.write_all(self.edit_records_fee.as_slice())?;
        writer.write_all(self.transfer_account_throttle.as_slice())?;
        writer.write_all(self.edit_manager_throttle.as_slice())?;
        writer.write_all(self.edit_records_throttle.as_slice())?;
        writer.write_all(self.common_throttle.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellAccountV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellProfitRateV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellProfitRateV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellProfitRateV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellProfitRateV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "inviter", self.inviter())?;
        write!(f, ", {}: {}", "channel", self.channel())?;
        write!(f, ", {}: {}", "proposal_create", self.proposal_create())?;
        write!(f, ", {}: {}", "proposal_confirm", self.proposal_confirm())?;
        write!(f, ", {}: {}", "income_consolidate", self.income_consolidate())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellProfitRateV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellProfitRateV1::new_unchecked(v.into())
    }
}
impl ConfigCellProfitRateV1 {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn inviter(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_create(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_confirm(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_consolidate(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellProfitRateV1Reader<'r> {
        ConfigCellProfitRateV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellProfitRateV1 {
    type Builder = ConfigCellProfitRateV1Builder;
    const NAME: &'static str = "ConfigCellProfitRateV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellProfitRateV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellProfitRateV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellProfitRateV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .inviter(self.inviter())
            .channel(self.channel())
            .proposal_create(self.proposal_create())
            .proposal_confirm(self.proposal_confirm())
            .income_consolidate(self.income_consolidate())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellProfitRateV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellProfitRateV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellProfitRateV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellProfitRateV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "inviter", self.inviter())?;
        write!(f, ", {}: {}", "channel", self.channel())?;
        write!(f, ", {}: {}", "proposal_create", self.proposal_create())?;
        write!(f, ", {}: {}", "proposal_confirm", self.proposal_confirm())?;
        write!(f, ", {}: {}", "income_consolidate", self.income_consolidate())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellProfitRateV1Reader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn inviter(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_create(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_confirm(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_consolidate(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellProfitRateV1Reader<'r> {
    type Entity = ConfigCellProfitRateV1;
    const NAME: &'static str = "ConfigCellProfitRateV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellProfitRateV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellProfitRateV1Builder {
    pub(crate) inviter: Uint32,
    pub(crate) channel: Uint32,
    pub(crate) proposal_create: Uint32,
    pub(crate) proposal_confirm: Uint32,
    pub(crate) income_consolidate: Uint32,
}
impl ConfigCellProfitRateV1Builder {
    pub const FIELD_COUNT: usize = 5;
    pub fn inviter(mut self, v: Uint32) -> Self {
        self.inviter = v;
        self
    }
    pub fn channel(mut self, v: Uint32) -> Self {
        self.channel = v;
        self
    }
    pub fn proposal_create(mut self, v: Uint32) -> Self {
        self.proposal_create = v;
        self
    }
    pub fn proposal_confirm(mut self, v: Uint32) -> Self {
        self.proposal_confirm = v;
        self
    }
    pub fn income_consolidate(mut self, v: Uint32) -> Self {
        self.income_consolidate = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellProfitRateV1Builder {
    type Entity = ConfigCellProfitRateV1;
    const NAME: &'static str = "ConfigCellProfitRateV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.inviter.as_slice().len()
            + self.channel.as_slice().len()
            + self.proposal_create.as_slice().len()
            + self.proposal_confirm.as_slice().len()
            + self.income_consolidate.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.inviter.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_create.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_confirm.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_consolidate.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.inviter.as_slice())?;
        writer.write_all(self.channel.as_slice())?;
        writer.write_all(self.proposal_create.as_slice())?;
        writer.write_all(self.proposal_confirm.as_slice())?;
        writer.write_all(self.income_consolidate.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellProfitRateV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellProfitRateV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellProfitRateV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellProfitRateV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellProfitRateV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "inviter", self.inviter())?;
        write!(f, ", {}: {}", "channel", self.channel())?;
        write!(f, ", {}: {}", "proposal_create", self.proposal_create())?;
        write!(f, ", {}: {}", "proposal_confirm", self.proposal_confirm())?;
        write!(f, ", {}: {}", "income_consolidate", self.income_consolidate())?;
        write!(f, ", {}: {}", "sale_inviter", self.sale_inviter())?;
        write!(f, ", {}: {}", "sale_channel", self.sale_channel())?;
        write!(f, ", {}: {}", "sale_das", self.sale_das())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellProfitRateV2 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            68, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellProfitRateV2::new_unchecked(v.into())
    }
}
impl ConfigCellProfitRateV2 {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn inviter(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_create(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_confirm(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_consolidate(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_inviter(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_channel(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_das(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellProfitRateV2Reader<'r> {
        ConfigCellProfitRateV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellProfitRateV2 {
    type Builder = ConfigCellProfitRateV2Builder;
    const NAME: &'static str = "ConfigCellProfitRateV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellProfitRateV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellProfitRateV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellProfitRateV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .inviter(self.inviter())
            .channel(self.channel())
            .proposal_create(self.proposal_create())
            .proposal_confirm(self.proposal_confirm())
            .income_consolidate(self.income_consolidate())
            .sale_inviter(self.sale_inviter())
            .sale_channel(self.sale_channel())
            .sale_das(self.sale_das())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellProfitRateV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellProfitRateV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellProfitRateV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellProfitRateV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "inviter", self.inviter())?;
        write!(f, ", {}: {}", "channel", self.channel())?;
        write!(f, ", {}: {}", "proposal_create", self.proposal_create())?;
        write!(f, ", {}: {}", "proposal_confirm", self.proposal_confirm())?;
        write!(f, ", {}: {}", "income_consolidate", self.income_consolidate())?;
        write!(f, ", {}: {}", "sale_inviter", self.sale_inviter())?;
        write!(f, ", {}: {}", "sale_channel", self.sale_channel())?;
        write!(f, ", {}: {}", "sale_das", self.sale_das())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellProfitRateV2Reader<'r> {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn inviter(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_create(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_confirm(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_consolidate(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_inviter(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_channel(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_das(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellProfitRateV2Reader<'r> {
    type Entity = ConfigCellProfitRateV2;
    const NAME: &'static str = "ConfigCellProfitRateV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellProfitRateV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint32Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint32Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint32Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellProfitRateV2Builder {
    pub(crate) inviter: Uint32,
    pub(crate) channel: Uint32,
    pub(crate) proposal_create: Uint32,
    pub(crate) proposal_confirm: Uint32,
    pub(crate) income_consolidate: Uint32,
    pub(crate) sale_inviter: Uint32,
    pub(crate) sale_channel: Uint32,
    pub(crate) sale_das: Uint32,
}
impl ConfigCellProfitRateV2Builder {
    pub const FIELD_COUNT: usize = 8;
    pub fn inviter(mut self, v: Uint32) -> Self {
        self.inviter = v;
        self
    }
    pub fn channel(mut self, v: Uint32) -> Self {
        self.channel = v;
        self
    }
    pub fn proposal_create(mut self, v: Uint32) -> Self {
        self.proposal_create = v;
        self
    }
    pub fn proposal_confirm(mut self, v: Uint32) -> Self {
        self.proposal_confirm = v;
        self
    }
    pub fn income_consolidate(mut self, v: Uint32) -> Self {
        self.income_consolidate = v;
        self
    }
    pub fn sale_inviter(mut self, v: Uint32) -> Self {
        self.sale_inviter = v;
        self
    }
    pub fn sale_channel(mut self, v: Uint32) -> Self {
        self.sale_channel = v;
        self
    }
    pub fn sale_das(mut self, v: Uint32) -> Self {
        self.sale_das = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellProfitRateV2Builder {
    type Entity = ConfigCellProfitRateV2;
    const NAME: &'static str = "ConfigCellProfitRateV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.inviter.as_slice().len()
            + self.channel.as_slice().len()
            + self.proposal_create.as_slice().len()
            + self.proposal_confirm.as_slice().len()
            + self.income_consolidate.as_slice().len()
            + self.sale_inviter.as_slice().len()
            + self.sale_channel.as_slice().len()
            + self.sale_das.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.inviter.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_create.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_confirm.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_consolidate.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_inviter.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_channel.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_das.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.inviter.as_slice())?;
        writer.write_all(self.channel.as_slice())?;
        writer.write_all(self.proposal_create.as_slice())?;
        writer.write_all(self.proposal_confirm.as_slice())?;
        writer.write_all(self.income_consolidate.as_slice())?;
        writer.write_all(self.sale_inviter.as_slice())?;
        writer.write_all(self.sale_channel.as_slice())?;
        writer.write_all(self.sale_das.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellProfitRateV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellSecondaryMarketV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellSecondaryMarketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellSecondaryMarketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellSecondaryMarketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min_sale_price", self.min_sale_price())?;
        write!(f, ", {}: {}", "sale_expiration_limit", self.sale_expiration_limit())?;
        write!(
            f,
            ", {}: {}",
            "sale_description_bytes_limit",
            self.sale_description_bytes_limit()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellSecondaryMarketV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            36, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,
        ];
        ConfigCellSecondaryMarketV1::new_unchecked(v.into())
    }
}
impl ConfigCellSecondaryMarketV1 {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min_sale_price(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_expiration_limit(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_description_bytes_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellSecondaryMarketV1Reader<'r> {
        ConfigCellSecondaryMarketV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellSecondaryMarketV1 {
    type Builder = ConfigCellSecondaryMarketV1Builder;
    const NAME: &'static str = "ConfigCellSecondaryMarketV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellSecondaryMarketV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSecondaryMarketV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSecondaryMarketV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .min_sale_price(self.min_sale_price())
            .sale_expiration_limit(self.sale_expiration_limit())
            .sale_description_bytes_limit(self.sale_description_bytes_limit())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellSecondaryMarketV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellSecondaryMarketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellSecondaryMarketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellSecondaryMarketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min_sale_price", self.min_sale_price())?;
        write!(f, ", {}: {}", "sale_expiration_limit", self.sale_expiration_limit())?;
        write!(
            f,
            ", {}: {}",
            "sale_description_bytes_limit",
            self.sale_description_bytes_limit()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellSecondaryMarketV1Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min_sale_price(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_expiration_limit(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_description_bytes_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellSecondaryMarketV1Reader<'r> {
    type Entity = ConfigCellSecondaryMarketV1;
    const NAME: &'static str = "ConfigCellSecondaryMarketV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellSecondaryMarketV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellSecondaryMarketV1Builder {
    pub(crate) min_sale_price: Uint64,
    pub(crate) sale_expiration_limit: Uint64,
    pub(crate) sale_description_bytes_limit: Uint32,
}
impl ConfigCellSecondaryMarketV1Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn min_sale_price(mut self, v: Uint64) -> Self {
        self.min_sale_price = v;
        self
    }
    pub fn sale_expiration_limit(mut self, v: Uint64) -> Self {
        self.sale_expiration_limit = v;
        self
    }
    pub fn sale_description_bytes_limit(mut self, v: Uint32) -> Self {
        self.sale_description_bytes_limit = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellSecondaryMarketV1Builder {
    type Entity = ConfigCellSecondaryMarketV1;
    const NAME: &'static str = "ConfigCellSecondaryMarketV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.min_sale_price.as_slice().len()
            + self.sale_expiration_limit.as_slice().len()
            + self.sale_description_bytes_limit.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.min_sale_price.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_expiration_limit.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_description_bytes_limit.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.min_sale_price.as_slice())?;
        writer.write_all(self.sale_expiration_limit.as_slice())?;
        writer.write_all(self.sale_description_bytes_limit.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellSecondaryMarketV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellSecondaryMarketV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellSecondaryMarketV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellSecondaryMarketV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellSecondaryMarketV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sale_min_price", self.sale_min_price())?;
        write!(f, ", {}: {}", "sale_expiration_limit", self.sale_expiration_limit())?;
        write!(
            f,
            ", {}: {}",
            "sale_description_bytes_limit",
            self.sale_description_bytes_limit()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_max_extendable_duration",
            self.auction_max_extendable_duration()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_duration_increment_each_bid",
            self.auction_duration_increment_each_bid()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_min_opening_price",
            self.auction_min_opening_price()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_min_increment_rate_each_bid",
            self.auction_min_increment_rate_each_bid()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_description_bytes_limit",
            self.auction_description_bytes_limit()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellSecondaryMarketV2 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            76, 0, 0, 0, 36, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 68, 0, 0, 0, 72,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellSecondaryMarketV2::new_unchecked(v.into())
    }
}
impl ConfigCellSecondaryMarketV2 {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn sale_min_price(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_expiration_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn sale_description_bytes_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn auction_max_extendable_duration(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn auction_duration_increment_each_bid(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn auction_min_opening_price(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn auction_min_increment_rate_each_bid(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn auction_description_bytes_limit(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellSecondaryMarketV2Reader<'r> {
        ConfigCellSecondaryMarketV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellSecondaryMarketV2 {
    type Builder = ConfigCellSecondaryMarketV2Builder;
    const NAME: &'static str = "ConfigCellSecondaryMarketV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellSecondaryMarketV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSecondaryMarketV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSecondaryMarketV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .sale_min_price(self.sale_min_price())
            .sale_expiration_limit(self.sale_expiration_limit())
            .sale_description_bytes_limit(self.sale_description_bytes_limit())
            .auction_max_extendable_duration(self.auction_max_extendable_duration())
            .auction_duration_increment_each_bid(self.auction_duration_increment_each_bid())
            .auction_min_opening_price(self.auction_min_opening_price())
            .auction_min_increment_rate_each_bid(self.auction_min_increment_rate_each_bid())
            .auction_description_bytes_limit(self.auction_description_bytes_limit())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellSecondaryMarketV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellSecondaryMarketV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellSecondaryMarketV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellSecondaryMarketV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sale_min_price", self.sale_min_price())?;
        write!(f, ", {}: {}", "sale_expiration_limit", self.sale_expiration_limit())?;
        write!(
            f,
            ", {}: {}",
            "sale_description_bytes_limit",
            self.sale_description_bytes_limit()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_max_extendable_duration",
            self.auction_max_extendable_duration()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_duration_increment_each_bid",
            self.auction_duration_increment_each_bid()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_min_opening_price",
            self.auction_min_opening_price()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_min_increment_rate_each_bid",
            self.auction_min_increment_rate_each_bid()
        )?;
        write!(
            f,
            ", {}: {}",
            "auction_description_bytes_limit",
            self.auction_description_bytes_limit()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellSecondaryMarketV2Reader<'r> {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn sale_min_price(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_expiration_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sale_description_bytes_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auction_max_extendable_duration(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auction_duration_increment_each_bid(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auction_min_opening_price(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auction_min_increment_rate_each_bid(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auction_description_bytes_limit(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellSecondaryMarketV2Reader<'r> {
    type Entity = ConfigCellSecondaryMarketV2;
    const NAME: &'static str = "ConfigCellSecondaryMarketV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellSecondaryMarketV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint32Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint32Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellSecondaryMarketV2Builder {
    pub(crate) sale_min_price: Uint64,
    pub(crate) sale_expiration_limit: Uint32,
    pub(crate) sale_description_bytes_limit: Uint32,
    pub(crate) auction_max_extendable_duration: Uint32,
    pub(crate) auction_duration_increment_each_bid: Uint32,
    pub(crate) auction_min_opening_price: Uint64,
    pub(crate) auction_min_increment_rate_each_bid: Uint32,
    pub(crate) auction_description_bytes_limit: Uint32,
}
impl ConfigCellSecondaryMarketV2Builder {
    pub const FIELD_COUNT: usize = 8;
    pub fn sale_min_price(mut self, v: Uint64) -> Self {
        self.sale_min_price = v;
        self
    }
    pub fn sale_expiration_limit(mut self, v: Uint32) -> Self {
        self.sale_expiration_limit = v;
        self
    }
    pub fn sale_description_bytes_limit(mut self, v: Uint32) -> Self {
        self.sale_description_bytes_limit = v;
        self
    }
    pub fn auction_max_extendable_duration(mut self, v: Uint32) -> Self {
        self.auction_max_extendable_duration = v;
        self
    }
    pub fn auction_duration_increment_each_bid(mut self, v: Uint32) -> Self {
        self.auction_duration_increment_each_bid = v;
        self
    }
    pub fn auction_min_opening_price(mut self, v: Uint64) -> Self {
        self.auction_min_opening_price = v;
        self
    }
    pub fn auction_min_increment_rate_each_bid(mut self, v: Uint32) -> Self {
        self.auction_min_increment_rate_each_bid = v;
        self
    }
    pub fn auction_description_bytes_limit(mut self, v: Uint32) -> Self {
        self.auction_description_bytes_limit = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellSecondaryMarketV2Builder {
    type Entity = ConfigCellSecondaryMarketV2;
    const NAME: &'static str = "ConfigCellSecondaryMarketV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.sale_min_price.as_slice().len()
            + self.sale_expiration_limit.as_slice().len()
            + self.sale_description_bytes_limit.as_slice().len()
            + self.auction_max_extendable_duration.as_slice().len()
            + self.auction_duration_increment_each_bid.as_slice().len()
            + self.auction_min_opening_price.as_slice().len()
            + self.auction_min_increment_rate_each_bid.as_slice().len()
            + self.auction_description_bytes_limit.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.sale_min_price.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_expiration_limit.as_slice().len();
        offsets.push(total_size);
        total_size += self.sale_description_bytes_limit.as_slice().len();
        offsets.push(total_size);
        total_size += self.auction_max_extendable_duration.as_slice().len();
        offsets.push(total_size);
        total_size += self.auction_duration_increment_each_bid.as_slice().len();
        offsets.push(total_size);
        total_size += self.auction_min_opening_price.as_slice().len();
        offsets.push(total_size);
        total_size += self.auction_min_increment_rate_each_bid.as_slice().len();
        offsets.push(total_size);
        total_size += self.auction_description_bytes_limit.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.sale_min_price.as_slice())?;
        writer.write_all(self.sale_expiration_limit.as_slice())?;
        writer.write_all(self.sale_description_bytes_limit.as_slice())?;
        writer.write_all(self.auction_max_extendable_duration.as_slice())?;
        writer.write_all(self.auction_duration_increment_each_bid.as_slice())?;
        writer.write_all(self.auction_min_opening_price.as_slice())?;
        writer.write_all(self.auction_min_increment_rate_each_bid.as_slice())?;
        writer.write_all(self.auction_description_bytes_limit.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellSecondaryMarketV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellSubAccountV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellSubAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellSubAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellSubAccountV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "new_sub_account_price", self.new_sub_account_price())?;
        write!(f, ", {}: {}", "renew_sub_account_price", self.renew_sub_account_price())?;
        write!(f, ", {}: {}", "common_fee", self.common_fee())?;
        write!(f, ", {}: {}", "create_fee", self.create_fee())?;
        write!(f, ", {}: {}", "edit_fee", self.edit_fee())?;
        write!(f, ", {}: {}", "renew_fee", self.renew_fee())?;
        write!(f, ", {}: {}", "recycle_fee", self.recycle_fee())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellSubAccountV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            112, 0, 0, 0, 40, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 88, 0, 0, 0,
            96, 0, 0, 0, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellSubAccountV1::new_unchecked(v.into())
    }
}
impl ConfigCellSubAccountV1 {
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn basic_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn prepared_fee_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn new_sub_account_price(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn renew_sub_account_price(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn common_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn create_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn edit_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn renew_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn recycle_fee(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellSubAccountV1Reader<'r> {
        ConfigCellSubAccountV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellSubAccountV1 {
    type Builder = ConfigCellSubAccountV1Builder;
    const NAME: &'static str = "ConfigCellSubAccountV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellSubAccountV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSubAccountV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSubAccountV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .basic_capacity(self.basic_capacity())
            .prepared_fee_capacity(self.prepared_fee_capacity())
            .new_sub_account_price(self.new_sub_account_price())
            .renew_sub_account_price(self.renew_sub_account_price())
            .common_fee(self.common_fee())
            .create_fee(self.create_fee())
            .edit_fee(self.edit_fee())
            .renew_fee(self.renew_fee())
            .recycle_fee(self.recycle_fee())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellSubAccountV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellSubAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellSubAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellSubAccountV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "basic_capacity", self.basic_capacity())?;
        write!(f, ", {}: {}", "prepared_fee_capacity", self.prepared_fee_capacity())?;
        write!(f, ", {}: {}", "new_sub_account_price", self.new_sub_account_price())?;
        write!(f, ", {}: {}", "renew_sub_account_price", self.renew_sub_account_price())?;
        write!(f, ", {}: {}", "common_fee", self.common_fee())?;
        write!(f, ", {}: {}", "create_fee", self.create_fee())?;
        write!(f, ", {}: {}", "edit_fee", self.edit_fee())?;
        write!(f, ", {}: {}", "renew_fee", self.renew_fee())?;
        write!(f, ", {}: {}", "recycle_fee", self.recycle_fee())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellSubAccountV1Reader<'r> {
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn basic_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prepared_fee_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn new_sub_account_price(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn renew_sub_account_price(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn common_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn create_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn edit_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn renew_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn recycle_fee(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellSubAccountV1Reader<'r> {
    type Entity = ConfigCellSubAccountV1;
    const NAME: &'static str = "ConfigCellSubAccountV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellSubAccountV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint64Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint64Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Uint64Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellSubAccountV1Builder {
    pub(crate) basic_capacity: Uint64,
    pub(crate) prepared_fee_capacity: Uint64,
    pub(crate) new_sub_account_price: Uint64,
    pub(crate) renew_sub_account_price: Uint64,
    pub(crate) common_fee: Uint64,
    pub(crate) create_fee: Uint64,
    pub(crate) edit_fee: Uint64,
    pub(crate) renew_fee: Uint64,
    pub(crate) recycle_fee: Uint64,
}
impl ConfigCellSubAccountV1Builder {
    pub const FIELD_COUNT: usize = 9;
    pub fn basic_capacity(mut self, v: Uint64) -> Self {
        self.basic_capacity = v;
        self
    }
    pub fn prepared_fee_capacity(mut self, v: Uint64) -> Self {
        self.prepared_fee_capacity = v;
        self
    }
    pub fn new_sub_account_price(mut self, v: Uint64) -> Self {
        self.new_sub_account_price = v;
        self
    }
    pub fn renew_sub_account_price(mut self, v: Uint64) -> Self {
        self.renew_sub_account_price = v;
        self
    }
    pub fn common_fee(mut self, v: Uint64) -> Self {
        self.common_fee = v;
        self
    }
    pub fn create_fee(mut self, v: Uint64) -> Self {
        self.create_fee = v;
        self
    }
    pub fn edit_fee(mut self, v: Uint64) -> Self {
        self.edit_fee = v;
        self
    }
    pub fn renew_fee(mut self, v: Uint64) -> Self {
        self.renew_fee = v;
        self
    }
    pub fn recycle_fee(mut self, v: Uint64) -> Self {
        self.recycle_fee = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellSubAccountV1Builder {
    type Entity = ConfigCellSubAccountV1;
    const NAME: &'static str = "ConfigCellSubAccountV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.basic_capacity.as_slice().len()
            + self.prepared_fee_capacity.as_slice().len()
            + self.new_sub_account_price.as_slice().len()
            + self.renew_sub_account_price.as_slice().len()
            + self.common_fee.as_slice().len()
            + self.create_fee.as_slice().len()
            + self.edit_fee.as_slice().len()
            + self.renew_fee.as_slice().len()
            + self.recycle_fee.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.basic_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.prepared_fee_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.new_sub_account_price.as_slice().len();
        offsets.push(total_size);
        total_size += self.renew_sub_account_price.as_slice().len();
        offsets.push(total_size);
        total_size += self.common_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.create_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.edit_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.renew_fee.as_slice().len();
        offsets.push(total_size);
        total_size += self.recycle_fee.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.basic_capacity.as_slice())?;
        writer.write_all(self.prepared_fee_capacity.as_slice())?;
        writer.write_all(self.new_sub_account_price.as_slice())?;
        writer.write_all(self.renew_sub_account_price.as_slice())?;
        writer.write_all(self.common_fee.as_slice())?;
        writer.write_all(self.create_fee.as_slice())?;
        writer.write_all(self.edit_fee.as_slice())?;
        writer.write_all(self.renew_fee.as_slice())?;
        writer.write_all(self.recycle_fee.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellSubAccountV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ConfigCellSystemStatusV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ConfigCellSystemStatusV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ConfigCellSystemStatusV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ConfigCellSystemStatusV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "apply_register_cell_type", self.apply_register_cell_type())?;
        write!(f, ", {}: {}", "pre_account_cell_type", self.pre_account_cell_type())?;
        write!(f, ", {}: {}", "proposal_cell_type", self.proposal_cell_type())?;
        write!(f, ", {}: {}", "config_cell_type", self.config_cell_type())?;
        write!(f, ", {}: {}", "account_cell_type", self.account_cell_type())?;
        write!(f, ", {}: {}", "account_sale_cell_type", self.account_sale_cell_type())?;
        write!(f, ", {}: {}", "sub_account_cell_type", self.sub_account_cell_type())?;
        write!(f, ", {}: {}", "offer_cell_type", self.offer_cell_type())?;
        write!(f, ", {}: {}", "balance_cell_type", self.balance_cell_type())?;
        write!(f, ", {}: {}", "income_cell_type", self.income_cell_type())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_cell_type",
            self.reverse_record_cell_type()
        )?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell_type",
            self.reverse_record_root_cell_type()
        )?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ConfigCellSystemStatusV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            21, 1, 0, 0, 56, 0, 0, 0, 73, 0, 0, 0, 90, 0, 0, 0, 107, 0, 0, 0, 124, 0, 0, 0, 141, 0, 0, 0, 158, 0, 0, 0,
            175, 0, 0, 0, 192, 0, 0, 0, 209, 0, 0, 0, 226, 0, 0, 0, 243, 0, 0, 0, 4, 1, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
            13, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ConfigCellSystemStatusV1::new_unchecked(v.into())
    }
}
impl ConfigCellSystemStatusV1 {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn apply_register_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn pre_account_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposal_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn config_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn account_sale_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn sub_account_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn offer_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn balance_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn income_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn reverse_record_root_cell_type(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        ContractStatus::new_unchecked(self.0.slice(start..end))
    }
    pub fn eip712_lib(&self) -> ContractStatus {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            ContractStatus::new_unchecked(self.0.slice(start..end))
        } else {
            ContractStatus::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ConfigCellSystemStatusV1Reader<'r> {
        ConfigCellSystemStatusV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ConfigCellSystemStatusV1 {
    type Builder = ConfigCellSystemStatusV1Builder;
    const NAME: &'static str = "ConfigCellSystemStatusV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ConfigCellSystemStatusV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSystemStatusV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ConfigCellSystemStatusV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .apply_register_cell_type(self.apply_register_cell_type())
            .pre_account_cell_type(self.pre_account_cell_type())
            .proposal_cell_type(self.proposal_cell_type())
            .config_cell_type(self.config_cell_type())
            .account_cell_type(self.account_cell_type())
            .account_sale_cell_type(self.account_sale_cell_type())
            .sub_account_cell_type(self.sub_account_cell_type())
            .offer_cell_type(self.offer_cell_type())
            .balance_cell_type(self.balance_cell_type())
            .income_cell_type(self.income_cell_type())
            .reverse_record_cell_type(self.reverse_record_cell_type())
            .reverse_record_root_cell_type(self.reverse_record_root_cell_type())
            .eip712_lib(self.eip712_lib())
    }
}
#[derive(Clone, Copy)]
pub struct ConfigCellSystemStatusV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ConfigCellSystemStatusV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ConfigCellSystemStatusV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ConfigCellSystemStatusV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "apply_register_cell_type", self.apply_register_cell_type())?;
        write!(f, ", {}: {}", "pre_account_cell_type", self.pre_account_cell_type())?;
        write!(f, ", {}: {}", "proposal_cell_type", self.proposal_cell_type())?;
        write!(f, ", {}: {}", "config_cell_type", self.config_cell_type())?;
        write!(f, ", {}: {}", "account_cell_type", self.account_cell_type())?;
        write!(f, ", {}: {}", "account_sale_cell_type", self.account_sale_cell_type())?;
        write!(f, ", {}: {}", "sub_account_cell_type", self.sub_account_cell_type())?;
        write!(f, ", {}: {}", "offer_cell_type", self.offer_cell_type())?;
        write!(f, ", {}: {}", "balance_cell_type", self.balance_cell_type())?;
        write!(f, ", {}: {}", "income_cell_type", self.income_cell_type())?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_cell_type",
            self.reverse_record_cell_type()
        )?;
        write!(
            f,
            ", {}: {}",
            "reverse_record_root_cell_type",
            self.reverse_record_root_cell_type()
        )?;
        write!(f, ", {}: {}", "eip712_lib", self.eip712_lib())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ConfigCellSystemStatusV1Reader<'r> {
    pub const FIELD_COUNT: usize = 13;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn apply_register_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pre_account_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposal_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn config_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn account_sale_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sub_account_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn offer_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balance_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn income_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn reverse_record_root_cell_type(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn eip712_lib(&self) -> ContractStatusReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[56..]) as usize;
            ContractStatusReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ContractStatusReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ConfigCellSystemStatusV1Reader<'r> {
    type Entity = ConfigCellSystemStatusV1;
    const NAME: &'static str = "ConfigCellSystemStatusV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ConfigCellSystemStatusV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ContractStatusReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        ContractStatusReader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ConfigCellSystemStatusV1Builder {
    pub(crate) apply_register_cell_type: ContractStatus,
    pub(crate) pre_account_cell_type: ContractStatus,
    pub(crate) proposal_cell_type: ContractStatus,
    pub(crate) config_cell_type: ContractStatus,
    pub(crate) account_cell_type: ContractStatus,
    pub(crate) account_sale_cell_type: ContractStatus,
    pub(crate) sub_account_cell_type: ContractStatus,
    pub(crate) offer_cell_type: ContractStatus,
    pub(crate) balance_cell_type: ContractStatus,
    pub(crate) income_cell_type: ContractStatus,
    pub(crate) reverse_record_cell_type: ContractStatus,
    pub(crate) reverse_record_root_cell_type: ContractStatus,
    pub(crate) eip712_lib: ContractStatus,
}
impl ConfigCellSystemStatusV1Builder {
    pub const FIELD_COUNT: usize = 13;
    pub fn apply_register_cell_type(mut self, v: ContractStatus) -> Self {
        self.apply_register_cell_type = v;
        self
    }
    pub fn pre_account_cell_type(mut self, v: ContractStatus) -> Self {
        self.pre_account_cell_type = v;
        self
    }
    pub fn proposal_cell_type(mut self, v: ContractStatus) -> Self {
        self.proposal_cell_type = v;
        self
    }
    pub fn config_cell_type(mut self, v: ContractStatus) -> Self {
        self.config_cell_type = v;
        self
    }
    pub fn account_cell_type(mut self, v: ContractStatus) -> Self {
        self.account_cell_type = v;
        self
    }
    pub fn account_sale_cell_type(mut self, v: ContractStatus) -> Self {
        self.account_sale_cell_type = v;
        self
    }
    pub fn sub_account_cell_type(mut self, v: ContractStatus) -> Self {
        self.sub_account_cell_type = v;
        self
    }
    pub fn offer_cell_type(mut self, v: ContractStatus) -> Self {
        self.offer_cell_type = v;
        self
    }
    pub fn balance_cell_type(mut self, v: ContractStatus) -> Self {
        self.balance_cell_type = v;
        self
    }
    pub fn income_cell_type(mut self, v: ContractStatus) -> Self {
        self.income_cell_type = v;
        self
    }
    pub fn reverse_record_cell_type(mut self, v: ContractStatus) -> Self {
        self.reverse_record_cell_type = v;
        self
    }
    pub fn reverse_record_root_cell_type(mut self, v: ContractStatus) -> Self {
        self.reverse_record_root_cell_type = v;
        self
    }
    pub fn eip712_lib(mut self, v: ContractStatus) -> Self {
        self.eip712_lib = v;
        self
    }
}
impl molecule::prelude::Builder for ConfigCellSystemStatusV1Builder {
    type Entity = ConfigCellSystemStatusV1;
    const NAME: &'static str = "ConfigCellSystemStatusV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.apply_register_cell_type.as_slice().len()
            + self.pre_account_cell_type.as_slice().len()
            + self.proposal_cell_type.as_slice().len()
            + self.config_cell_type.as_slice().len()
            + self.account_cell_type.as_slice().len()
            + self.account_sale_cell_type.as_slice().len()
            + self.sub_account_cell_type.as_slice().len()
            + self.offer_cell_type.as_slice().len()
            + self.balance_cell_type.as_slice().len()
            + self.income_cell_type.as_slice().len()
            + self.reverse_record_cell_type.as_slice().len()
            + self.reverse_record_root_cell_type.as_slice().len()
            + self.eip712_lib.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.apply_register_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.pre_account_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposal_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.config_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.account_sale_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.sub_account_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.offer_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.balance_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.income_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.reverse_record_root_cell_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.eip712_lib.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.apply_register_cell_type.as_slice())?;
        writer.write_all(self.pre_account_cell_type.as_slice())?;
        writer.write_all(self.proposal_cell_type.as_slice())?;
        writer.write_all(self.config_cell_type.as_slice())?;
        writer.write_all(self.account_cell_type.as_slice())?;
        writer.write_all(self.account_sale_cell_type.as_slice())?;
        writer.write_all(self.sub_account_cell_type.as_slice())?;
        writer.write_all(self.offer_cell_type.as_slice())?;
        writer.write_all(self.balance_cell_type.as_slice())?;
        writer.write_all(self.income_cell_type.as_slice())?;
        writer.write_all(self.reverse_record_cell_type.as_slice())?;
        writer.write_all(self.reverse_record_root_cell_type.as_slice())?;
        writer.write_all(self.eip712_lib.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ConfigCellSystemStatusV1::new_unchecked(inner.into())
    }
}
